"""
❯ ls
assets  commands.txt  config.h.in  docs  LICENSE  meson.build  README.md  src
❯ tree -L 3 ./
./
├── assets
│   ├── analytics_option.jpg
│   ├── demo_facad.jpg
│   ├── facad_2_18.jpg
│   └── long_listing_option.jpg
├── commands.txt
├── config.h.in
├── docs
│   └── man
│       └── facad.1
├── LICENSE
├── meson.build
├── README.md
└── src
    ├── args_parser.c
    ├── args_parser.h
    ├── dev_dir_utils.c
    ├── dev_dir_utils.h
    ├── dir_analytics.c
    ├── dir_analytics.h
    ├── dir_config.c
    ├── dir_config.h
    ├── display_utils.c
    ├── display_utils.h
    ├── emoji_mappings.c
    ├── emoji_mappings.h
    ├── emoji_utils.c
    ├── emoji_utils.h
    ├── file_card.c
    ├── file_card.h
    ├── git_integration.c
    ├── git_integration.h
    ├── git_utils.c
    ├── git_utils.h
    ├── longlisting.c
    ├── longlisting.h
    └── main.c

5 directories, 33 files
❯ ls
assets  commands.txt  config.h.in  docs  LICENSE  meson.build  README.md  src
❯ cat README.md 
# facad

[![Documentation](https://img.shields.io/badge/documentation-view-f5b836.svg?style=flat-square)](https://yellow-footed-honeyguide.github.io/facad/)
[![versions](https://img.shields.io/repology/repositories/facad?style=flat-square&color=f5b836)](https://repology.org/project/facad/versions)
[![Homebrew](https://img.shields.io/homebrew/installs/dy/facad?style=flat-square&color=f5b836&label=homebrew%20installs)](https://formulae.brew.sh/formula/facad)

A modern, colorful directory listing tool for the command line.

![facad in action](assets/facad_2_18.jpg)


## Features
> Designed for both novice users and power users,<br>
> facad feature set aims to enhance file management experience with<br>
> a perfect blend of functionality and simplicity.

- Intuitive file type representation 
- Sorted output with directories first
- Four-column layout for quick directory analysis
- Supports symlinks and executable files
- Sort extensions
- Unicode-aware formatting 


## Getting Started
### Dependencies
- Pure C implementation without any dependency

### macOS
facad is available through Homebrew. To install, run:
```bash
brew install facad
```

### I use Arch btw?
Just use the script from AUR:
```bash
yay -S facad
```

### Build & Install from source
```bash
git clone https://github.com/yellow-footed-honeyguide/facad.git
cd facad
meson setup build && meson compile -C build
# now facad binary in build dir

# for system-wide installation (may require elevated privileges like `sudo`):
cd build && sudo ninja install
```

## Usage

Run `facad` command for default grid file listing<br>
Run `facad -h/--help` command for help<br>
Run `facad -v--version` command for version<br>
Run `facad -l/--long` command for long listing output<br>
Run `facad -a/--analytics` command for dir analytics output



## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

- Fork the Project
- Create your Feature Branch ( `git checkout -b feature/AmazingFeature` )
- Commit your Changes ( `git commit -m 'Add some AmazingFeature'` )
- Push to the Branch ( `git push origin feature/AmazingFeature` )
- Open a Pull Request

## Author
**Sergey Veneckiy**
- Email: s.venetsky@gmail.com
- GitHub: [@yellow-footed-honeyguide](https://github.com/yellow-footed-honeyguide)


## License
Distributed under the MIT License. See LICENSE for more information.
❯ cat meson.build 
project('facad', 'c',
  version : '2.20.13',
  default_options : ['warning_level=3'])

cc = meson.get_compiler('c')

math_dep = cc.find_library('m', required : false)

src_files = [
  'src/main.c',
  'src/file_card.c',
  'src/dir_config.c',
  'src/emoji_utils.c',
  'src/args_parser.c',
  'src/longlisting.c',
  'src/dir_analytics.c',
  'src/dev_dir_utils.c',
  'src/display_utils.c',
  'src/emoji_mappings.c',
  'src/git_utils.c',
  'src/git_integration.c',
]

version = meson.project_version()

conf_data = configuration_data()
conf_data.set_quoted('VERSION', version)

configure_file(
  output : 'config.h',
  configuration : conf_data
)

inc = include_directories('.')

executable('facad',
           src_files,
           include_directories : inc,
           dependencies : [math_dep],
           install : true)

# Install man page
install_man('docs/man/facad.1')
❯ ls
assets  commands.txt  config.h.in  docs  LICENSE  meson.build  README.md  src
❯ cd src/
❯ ls
args_parser.c    dev_dir_utils.h  dir_config.c     display_utils.h   emoji_utils.c  file_card.h        git_utils.c    longlisting.h
args_parser.h    dir_analytics.c  dir_config.h     emoji_mappings.c  emoji_utils.h  git_integration.c  git_utils.h    main.c
dev_dir_utils.c  dir_analytics.h  display_utils.c  emoji_mappings.h  file_card.c    git_integration.h  longlisting.c
❯ cat *
/**
 * @file args_parser.c
 * @brief Implementation of command-line argument parsing for facad.
 *
 * This file contains functions for parsing command-line arguments,
 * identifying options, and handling version and help requests.
 * It also includes utility functions for working with file patterns.
 *
 * @author Sergey Veneckiy
 * @date 2024
 */

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "config.h"
#include "args_parser.h"

/**
 * @brief Checks if a string is a glob pattern.
 *
 * This function determines whether a given string contains
 * wildcard characters used in glob patterns.
 *
 * @param str The string to check for glob pattern characters.
 * @return true if the string contains glob pattern characters, false otherwise.
 */
bool is_glob_pattern(const char *str) {
    // Check for the presence of wildcard characters
    return (strchr(str, '*') != NULL || strchr(str, '?') != NULL || strchr(str, '[') != NULL);
}

/**
 * @brief Parses command-line arguments.
 *
 * This function processes the command-line arguments, setting appropriate flags
 * in the CommandLineArgs structure and collecting non-option arguments as targets.
 *
 * @param argc The number of command-line arguments.
 * @param argv An array of strings containing the command-line arguments.
 * @return A CommandLineArgs structure containing the parsed arguments.
 */
CommandLineArgs parse_args(int argc, char *argv[]) {
    CommandLineArgs args = {0};  // Initialize the args structure with zeros
    args.targets = malloc(sizeof(char*) * (argc - 1));  // Allocate memory for targets
    args.target_count = 0;  // Initialize target count to 0

    // Loop through all arguments starting from index 1 (skip program name)
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-v") == 0 || strcmp(argv[i], "--version") == 0) {
            args.show_version = true;  // Set flag to show version
        } else if (strcmp(argv[i], "-h") == 0 || strcmp(argv[i], "--help") == 0) {
            args.show_help = true;  // Set flag to show help
        } else if (strcmp(argv[i], "-l") == 0 || strcmp(argv[i], "--long") == 0) {
            args.show_longlisting = true;  // Set flag for long listing
        } else if (strcmp(argv[i], "-a") == 0 || strcmp(argv[i], "--analytics") == 0) {
            args.show_dir_analytics = true;  // Set flag for directory analytics
        } else if (argv[i][0] == '-') {
            args.invalid_opt = argv[i];  // Store invalid option
            return args;  // Return immediately on invalid option
        } else {
            args.targets[args.target_count++] = argv[i];  // Store non-option argument as target
        }
    }

    return args;  // Return the populated CommandLineArgs structure
}

/**
 * @brief Frees memory allocated for command-line arguments.
 *
 * This function releases the memory allocated for the targets array
 * in the CommandLineArgs structure.
 *
 * @param args Pointer to the CommandLineArgs structure to be freed.
 */
void free_args(CommandLineArgs *args) {
    if (args->targets) {
        free(args->targets);  // Free the targets array
        args->targets = NULL;  // Set pointer to NULL to prevent double-free
    }
}

/**
 * @brief Prints the version information of facad.
 *
 * This function displays the version number of the facad program,
 * which is defined in the config.h file.
 */
void print_version(void) {
    printf("facad version %s\n", VERSION);  // Print version number
}

/**
 * @brief Prints the help information for facad.
 *
 * This function displays usage information and available options
 * for the facad program.
 *
 * @param program_name The name of the program executable.
 */
void print_help(const char *program_name) {
    printf("Usage: %s [OPTION] [DIRECTORY]\n", program_name);
    printf("List directory contents with colorful emojis.\n\n");
    printf("Options:\n");
    printf("  -h, --help      display this help and exit\n");
    printf("  -v, --version   output version information and exit\n");
    printf("  -l, --long      display detailed directory listing\n");
    printf("  -a, --analytics display directory analytics\n");
    printf("\nIf DIRECTORY is not specified, the current directory is used.\n");
}
/**
 * @file args_parser.h
 * @brief Header file for command-line argument parsing in facad.
 *
 * This file declares structures and functions for parsing and handling
 * command-line arguments in the facad directory listing tool. It defines
 * the CommandLineArgs structure and related functions for argument processing.
 *
 * @author Sergey Veneckiy
 * @date 2024
 */

#ifndef ARGS_PARSER_H
#define ARGS_PARSER_H

#include <stdbool.h>  // Include for boolean type

/**
 * @struct CommandLineArgs
 * @brief Structure to hold parsed command-line arguments.
 *
 * This structure stores flags for various options and an array of target
 * directories or files specified in the command line.
 */
typedef struct
{
    bool show_version;        // Flag to show version information
    bool show_help;           // Flag to show help information
    bool show_longlisting;    // Flag to show detailed directory listing
    bool show_dir_analytics;  // Flag to show directory analytics
    const char *invalid_opt;  // Stores any invalid option encountered
    const char **targets;     // Array of target directories or files
    int target_count;         // Number of targets specified
} CommandLineArgs;

/**
 * @brief Parses command-line arguments.
 *
 * This function processes the command-line arguments, setting appropriate flags
 * in the CommandLineArgs structure and collecting non-option arguments as targets.
 *
 * @param argc The number of command-line arguments.
 * @param argv An array of strings containing the command-line arguments.
 * @return A CommandLineArgs structure containing the parsed arguments.
 */
CommandLineArgs parse_args(int argc, char *argv[]);

/**
 * @brief Frees memory allocated for command-line arguments.
 *
 * This function releases the memory allocated for the targets array
 * in the CommandLineArgs structure.
 *
 * @param args Pointer to the CommandLineArgs structure to be freed.
 */
void free_args(CommandLineArgs *args);

/**
 * @brief Prints the version information of facad.
 *
 * This function displays the version number of the facad program.
 */
void print_version(void);

/**
 * @brief Prints the help information for facad.
 *
 * This function displays usage information and available options
 * for the facad program.
 *
 * @param program_name The name of the program executable.
 */
void print_help(const char *program_name);

/**
 * @brief Checks if a string is a glob pattern.
 *
 * This function determines whether a given string contains
 * wildcard characters used in glob patterns.
 *
 * @param str The string to check for glob pattern characters.
 * @return true if the string contains glob pattern characters, false otherwise.
 */
bool is_glob_pattern(const char *str);

#endif // ARGS_PARSER_H
/**
 * @file dev_dir_utils.c
 * @brief Utility functions for handling the /dev directory
 *
 * This file contains functions to identify and process entries in the /dev
 * directory, which contains device files on Unix-like systems.
 *
 * @author Sergey Veneckiy
 * @date 2024
 */

#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <errno.h>

#include "dev_dir_utils.h"
#include "emoji_utils.h"

#define MAX_PATH 4096 // Maximum path length
#define INITIAL_DEV_ENTRIES 64 // Initial number of entries for /dev

/**
 * @brief Checks if the given path is the /dev directory
 *
 * @param path The path to check
 * @return 1 if the path is "/dev", 0 otherwise
 */
int is_dev_directory(const char *path)
{
    // Compare the given path with "/dev"
    return strcmp(path, "/dev") == 0;
}

/**
 * @brief Processes the contents of the /dev directory
 *
 * This function reads the entries in the /dev directory, creates FileCardInfo
 * structures for each entry, and stores them in the provided array.
 *
 * @param entries Pointer to an array of FileCardInfo pointers
 * @param num_entries Pointer to the number of entries in the array
 * @param current_size Pointer to the current size of the array
 * @return 0 on success, -1 on failure
 */
int handle_dev_directory(FileCardInfo **entries, int *num_entries, int *current_size)
{
    DIR *dir = opendir("/dev");  // Open the /dev directory
    if (!dir)
    {
        perror("Error opening /dev");  // Print error message if opening fails
        return -1;  // Return -1 to indicate failure
    }

    struct dirent *d_entry;  // Structure to hold directory entry information
    char full_path[MAX_PATH];  // Buffer to store full path of each entry
    struct stat st;  // Structure to hold file status information

    // Initialize entries if not already initialized
    if (*entries == NULL) {
        *entries = malloc(INITIAL_DEV_ENTRIES * sizeof(FileCardInfo));  // Allocate initial memory
        if (*entries == NULL) {
            perror("Failed to allocate initial memory for /dev entries");  // Print error if allocation fails
            closedir(dir);  // Close the directory
            return -1;  // Return -1 to indicate failure
        }
        *current_size = INITIAL_DEV_ENTRIES;  // Set current size to initial size
    }

    while ((d_entry = readdir(dir)) != NULL)  // Read each entry in the directory
    {
        if (strcmp(d_entry->d_name, ".") == 0 || strcmp(d_entry->d_name, "..") == 0)
        {
            continue; // Skip the . and .. entries
        }

        // Check if we need to allocate more memory
        if (*num_entries >= *current_size)
        {
            int new_size = *current_size * 2;  // Double the current size
            FileCardInfo *new_entries = realloc(*entries, new_size * sizeof(FileCardInfo));  // Reallocate memory
            if (!new_entries)
            {
                fprintf(stderr, "Failed to reallocate memory for /dev entries: %s\n", strerror(errno));  // Print error message
                closedir(dir);  // Close the directory
                return -1;  // Return -1 to indicate failure
            }
            *entries = new_entries;  // Update the entries pointer
            *current_size = new_size;  // Update the current size
        }

        // Construct the full path to the file in /dev
        snprintf(full_path, sizeof(full_path), "/dev/%s", d_entry->d_name);

        if (lstat(full_path, &st) == 0)  // Get file status
        {
            FileCardInfo *entry = &((*entries)[*num_entries]);  // Get pointer to current entry
            entry->name = strdup(d_entry->d_name);  // Duplicate the entry name
            if (entry->name == NULL)
            {
                perror("strdup");  // Print error message if strdup fails
                closedir(dir);  // Close the directory
                return -1;  // Return -1 to indicate failure
            }

            entry->is_directory = S_ISDIR(st.st_mode);  // Check if it's a directory
            entry->is_hidden = (d_entry->d_name[0] == '.');  // Check if it's a hidden file

            if (S_ISLNK(st.st_mode))  // Check if it's a symbolic link
            {
                entry->emoji = strdup(entry->is_directory ? "🔗📁" : "🔗");  // Use link emoji
            }
            else if (entry->is_directory)
            {
                entry->emoji = strdup("📁");  // Use folder emoji for directories
            }
            else
            {
                entry->emoji = get_dev_emoji(d_entry->d_name);  // Get appropriate emoji for device file
            }

            if (entry->emoji == NULL)
            {
                fprintf(stderr, "Failed to allocate memory for emoji: %s\n", strerror(errno));  // Print error message
                free(entry->name);  // Free the allocated name
                closedir(dir);  // Close the directory
                return -1;  // Return -1 to indicate failure
            }

            (*num_entries)++; // Increment the number of entries
        }
    }

    closedir(dir);  // Close the directory
    return 0;  // Return 0 to indicate success
}
/**
 * @file dev_dir_utils.h
 * @brief Utility functions for handling the /dev directory
 *
 * This header file declares functions for identifying and processing
 * entries in the /dev directory, which contains device files on Unix-like systems.
 *
 * @author Sergey Veneckiy
 * @date 2024
 */

#ifndef DEV_UTILS_H
#define DEV_UTILS_H

#include "file_card.h"

#ifdef __cplusplus
extern "C"
{
#endif

    /**
     * @brief Checks if the specified path is the /dev directory
     *
     * This function determines whether the given path represents
     * the /dev directory.
     *
     * @param path Path to check
     * @return 1 if the path is "/dev", 0 otherwise
     */
    int is_dev_directory(const char *path);

    /**
     * @brief Processes the contents of the /dev directory
     *
     * This function reads and processes the entries in the /dev directory,
     * creating FileCardInfo structures for each entry and storing them
     * in the provided array. It handles memory allocation and reallocation
     * as needed.
     *
     * @param entries Double pointer to an array of FileCardInfo structures that will be populated
     * @param num_entries Pointer to the current number of entries in the array
     * @param current_size Pointer to the current size of the array
     * @return 0 on success, -1 on failure
     */
    int handle_dev_directory(FileCardInfo **entries, int *num_entries, int *current_size);

#ifdef __cplusplus
}
#endif

#endif // DEV_UTILS_H
/**
 * @file dir_analytics.c
 * @brief Implementation of directory analytics functionality.
 *
 * This file contains functions for analyzing directory contents,
 * including calculation of total size, file counts, depth analysis,
 * and identification of largest and newest files.
 *
 * @author Sergey Veneckiy
 * @date 2024
 */

#include <pwd.h>
#include <grp.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <sys/stat.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>

#include "emoji_utils.h"
#include "dir_analytics.h"

#define MAX_PATH 4096
#define MAX_FILES 1024

// ANSI escape codes for text formatting
#define ANSI_BOLD "\033[1m"
#define ANSI_RESET "\033[0m"

/**
 * @brief Formats a file size into a human-readable string.
 *
 * @param size The size in bytes to format.
 * @return A pointer to a static buffer containing the formatted size string.
 */
static char* format_size(off_t size) {
    static char buf[64];
    const char* units[] = {"B", "K", "M", "G", "T", "P", "E", "Z", "Y"};
    int i = 0;
    double dsize = size;

    // Convert size to appropriate unit
    while (dsize >= 1024 && i < 8) {
        dsize /= 1024;
        i++;
    }

    // Format the size with one decimal place
    snprintf(buf, sizeof(buf), "%.1f%s", dsize, units[i]);
    return buf;
}

/**
 * @brief Formats a time_t value into a human-readable string.
 *
 * @param t The time_t value to format.
 * @return A pointer to a static buffer containing the formatted time string.
 */
static char* format_time(time_t t) {
    static char buf[20];
    struct tm* tm_info = localtime(&t);
    strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", tm_info);
    return buf;
}

/**
 * @brief Recursively scans a directory to find its maximum depth.
 *
 * @param path The path of the directory to scan.
 * @param max_depth Pointer to the current maximum depth.
 * @param current_depth The current depth in the recursion.
 * @param deepest_dir Buffer to store the path of the deepest directory.
 */
static void recursive_dir_scan(const char* path, int* max_depth, int current_depth, char* deepest_dir) {
    DIR* dir;
    struct dirent* entry;
    char full_path[MAX_PATH];

    dir = opendir(path);
    if (!dir) return;

    while ((entry = readdir(dir)) != NULL) {
        // Skip . and .. entries
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) continue;

        snprintf(full_path, sizeof(full_path), "%s/%s", path, entry->d_name);

        struct stat st;
        if (lstat(full_path, &st) == 0 && S_ISDIR(st.st_mode)) {
            int new_depth = current_depth + 1;
            // Update max_depth and deepest_dir if a new maximum is found
            if (new_depth > *max_depth) {
                *max_depth = new_depth;
                strncpy(deepest_dir, full_path, MAX_PATH - 1);
                deepest_dir[MAX_PATH - 1] = '\0';
            }
            // Recursively scan subdirectory
            recursive_dir_scan(full_path, max_depth, new_depth, deepest_dir);
        }
    }
    closedir(dir);
}

/**
 * @brief Calculates the total size of a directory and its contents.
 *
 * @param path The path of the directory to analyze.
 * @return The total size of the directory in bytes.
 */
static off_t calculate_total_size(const char* path) {
    DIR* dir;
    struct dirent* entry;
    struct stat st;
    off_t total_size = 0;
    char full_path[MAX_PATH];
    static long block_size = 0;

    // Determine the filesystem block size
    if (block_size == 0) {
        block_size = 512; // Default value
#ifdef ST_BLKSIZE
        struct statvfs buf;
        if (statvfs(path, &buf) == 0) {
            block_size = buf.f_frsize;
        }
#endif
    }

    dir = opendir(path);
    if (!dir) {
        fprintf(stderr, "Error opening directory %s: %s\n", path, strerror(errno));
        return 0;
    }

    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) continue;

        snprintf(full_path, sizeof(full_path), "%s/%s", path, entry->d_name);

        if (lstat(full_path, &st) == 0) {
            if (S_ISDIR(st.st_mode)) {
                // Recursively calculate size for subdirectories
                total_size += calculate_total_size(full_path);
            } else if (S_ISREG(st.st_mode)) {
                // Add file size, rounded up to the nearest block
                total_size += (st.st_blocks * 512 + block_size - 1) / block_size * block_size;
            }
            // Ignore symbolic links and other special files
        } else {
            fprintf(stderr, "Error stating %s: %s\n", full_path, strerror(errno));
        }
    }
    closedir(dir);
    return total_size;
}

/**
 * @brief Recursively finds the largest file in a directory and its subdirectories.
 *
 * @param path The path of the directory to scan.
 * @param largest_size Pointer to store the size of the largest file found.
 * @param largest_file Buffer to store the path of the largest file.
 * @param largest_file_size Size of the largest_file buffer.
 */
static void find_largest_file(const char* path, off_t* largest_size, char* largest_file, size_t largest_file_size) {
    DIR* dir;
    struct dirent* entry;
    char full_path[MAX_PATH];

    dir = opendir(path);
    if (!dir) return;

    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) continue;

        snprintf(full_path, sizeof(full_path), "%s/%s", path, entry->d_name);

        struct stat st;
        if (lstat(full_path, &st) == 0) {
            if (S_ISDIR(st.st_mode)) {
                // Recursively scan subdirectories
                find_largest_file(full_path, largest_size, largest_file, largest_file_size);
            } else if (S_ISREG(st.st_mode)) {
                // Check if this file is larger than the current largest
                if (st.st_size > *largest_size) {
                    *largest_size = st.st_size;
                    strncpy(largest_file, full_path, largest_file_size - 1);
                    largest_file[largest_file_size - 1] = '\0';
                }
            }
        }
    }
    closedir(dir);
}


/**
 * @brief Prints detailed analytics about a directory.
 *
 * This function analyzes the contents of the specified directory
 * and prints various statistics including total size, file counts,
 * directory depth, and information about largest and newest files.
 *
 * @param path The path of the directory to analyze.
 */
void print_dir_analytics(const char* path) {
    DIR* dir;
    struct dirent* entry;
    struct stat st;
    off_t largest_size = 0;
    int total_files = 0, total_dirs = 0, empty_files = 0, max_depth = 0;
    time_t newest_time = 0, oldest_time = time(NULL);
    char largest_file[MAX_PATH] = "", newest_file[MAX_PATH] = "", oldest_file[MAX_PATH] = "";
    char empty_file_names[MAX_FILES][256];
    char deepest_dir[MAX_PATH] = "";

    dir = opendir(path);
    if (!dir) {
        perror("Error opening directory");
        return;
    }

    // Find the largest file recursively
    find_largest_file(path, &largest_size, largest_file, sizeof(largest_file));

    // Calculate total size recursively
    off_t total_size = calculate_total_size(path);

    while ((entry = readdir(dir)) != NULL) {
        char full_path[MAX_PATH];
        snprintf(full_path, sizeof(full_path), "%s/%s", path, entry->d_name);
        if (lstat(full_path, &st) != 0) continue;

        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) continue;

        if (S_ISDIR(st.st_mode)) {
            total_dirs++;
        } else if (S_ISREG(st.st_mode)) {
            total_files++;

            // Check for largest file
            if (st.st_size > largest_size) {
                largest_size = st.st_size;
                strncpy(largest_file, entry->d_name, sizeof(largest_file) - 1);
            }

            // Check for newest file
            if (st.st_mtime > newest_time) {
                newest_time = st.st_mtime;
                strncpy(newest_file, entry->d_name, sizeof(newest_file) - 1);
            }

            // Check for oldest file
            if (st.st_mtime < oldest_time) {
                oldest_time = st.st_mtime;
                strncpy(oldest_file, entry->d_name, sizeof(oldest_file) - 1);
            }

            // Check for empty files
            if (st.st_size == 0) {
                strncpy(empty_file_names[empty_files], entry->d_name, 255);
                empty_file_names[empty_files][255] = '\0';
                empty_files++;
            }
        }
    }
    closedir(dir);

    // Calculate max depth and find deepest directory
    recursive_dir_scan(path, &max_depth, 0, deepest_dir);

    char cwd[MAX_PATH];
    if (getcwd(cwd, sizeof(cwd)) == NULL) {
        perror("getcwd() error");
        return;
    }

    // Print analytics
    printf("%s%s%s\n", ANSI_BOLD, cwd, ANSI_RESET);
    printf("🧮 Total Size    : %s\n", format_size(total_size));
    printf("🗂️  Directories   : %d\n", total_dirs);
    printf("🌳 Max Depth     : %d levels\n", max_depth);
    printf("📁 Deepest Dir   : %s\n", deepest_dir);
    printf("🗃️  Files         : %d\n", total_files);
    printf("🐘 Largest File  : %s [%s]\n", largest_file, format_size(largest_size));
    printf("🏺 Oldest File   : %s [%s]\n", oldest_file, format_time(oldest_time));
    printf("🆕 Newest File   : %s [%s]\n", newest_file, format_time(newest_time));
    printf("📭 Empty Files   : %d [", empty_files);

    // Print names of empty files
    for (int i = 0; i < empty_files; i++) {
        printf("%s%s", empty_file_names[i], (i + 1 < empty_files) ? " " : "");
    }
    printf("]\n");
}
/**
 * @file dir_analytics.h
 * @brief Header file for directory analysis functionality
 *
 * This file contains the declaration of functions for generating
 * and displaying detailed analytics about directory contents.
 * It provides an interface for examining file sizes, counts,
 * timestamps, and other attributes within a directory structure.
 *
 * @author Sergey Veneckiy
 * @date 2024
 */

#ifndef DIR_ANALYTICS_H
#define DIR_ANALYTICS_H

/**
 * @brief Prints detailed analytics about a directory
 *
 * This function analyzes the contents of the specified directory
 * and prints various statistics including:
 * - Total size of all files
 * - Number of files and directories
 * - Depth of the directory tree
 * - File size ranges (smallest and largest)
 * - Newest and oldest files
 * - File type distributions
 * - Permissions and ownership information
 *
 * The analytics provide a comprehensive overview of the directory's
 * contents, useful for storage management and content analysis.
 *
 * @param path The path of the directory to analyze
 *
 * @note This function performs a recursive analysis and may take
 *       considerable time for large directory structures.
 *
 * @warning For very large directories, this function may consume
 *          significant memory and processing resources.
 */
void print_dir_analytics(const char *path);

#endif // DIR_ANALYTICS_H
/**
 * @file dir_config.c
 * @brief Implementation of directory configuration functions.
 *
 * This file contains the implementation of functions related to
 * directory-specific configurations, particularly for setting
 * the maximum number of columns for directory listings.
 *
 * @author Sergey Veneckiy
 * @date 2024
 */

#include "dir_config.h"
#include <string.h>

/**
 * @brief Array of directory configurations.
 *
 * This array defines special configurations for specific directories,
 * setting a custom maximum number of columns for their listings.
 */
const DirectoryConfig directory_configs[] = {
    {"/dev", 6},  // Set 6 columns for /dev directory
    {"/proc", 5}, // Set 5 columns for /proc directory
};

/**
 * @brief Number of entries in the directory_configs array.
 */
const int num_directory_configs = sizeof(directory_configs) / sizeof(directory_configs[0]);

/**
 * @brief Get the maximum number of columns for a given directory path.
 *
 * This function checks if the given path matches any of the specially
 * configured directories and returns the corresponding maximum number
 * of columns. If no match is found, it returns the default value.
 *
 * @param path The directory path to check.
 * @return The maximum number of columns for the directory listing.
 */
int get_max_columns(const char *path) {
    // Iterate through the directory configurations
    for (int i = 0; i < num_directory_configs; i++) {
        // Check if the path matches a configured directory
        if (strcmp(path, directory_configs[i].path) == 0) {
            // Return the custom max columns for the matched directory
            return directory_configs[i].max_columns;
        }
    }

    // If no match found, return the default maximum columns
    return DEFAULT_MAX_COLUMNS;
}
/**
 * @file dir_config.h
 * @brief Header file for directory-specific configurations.
 *
 * This file declares structures and functions for managing
 * directory-specific configurations, particularly for customizing
 * the display of directory listings.
 *
 * @author Sergey Veneckiy
 * @date 2024
 */

#ifndef DIRECTORY_CONFIG_H
#define DIRECTORY_CONFIG_H

/**
 * @brief Default maximum number of columns for directory listings.
 *
 * This value is used when no specific configuration is found for a directory.
 */
#define DEFAULT_MAX_COLUMNS 4

/**
 * @struct DirectoryConfig
 * @brief Structure to hold directory-specific configuration.
 *
 * This structure associates a directory path with its custom
 * maximum number of columns for listing display.
 */
typedef struct {
    const char *path;      /**< Path of the directory */
    int max_columns;       /**< Maximum number of columns for listing */
} DirectoryConfig;

/**
 * @brief Array of directory configurations.
 *
 * This extern declaration makes the array of DirectoryConfig structures
 * available to other source files that include this header.
 */
extern const DirectoryConfig directory_configs[];

/**
 * @brief Number of entries in the directory_configs array.
 *
 * This extern declaration makes the count of directory configurations
 * available to other source files that include this header.
 */
extern const int num_directory_configs;

/**
 * @brief Get the maximum number of columns for a given directory path.
 *
 * This function determines the maximum number of columns to use when
 * displaying the contents of the specified directory. It checks for
 * custom configurations and returns the default if none is found.
 *
 * @param path The path of the directory to check.
 * @return The maximum number of columns for the directory listing.
 */
int get_max_columns(const char *path);

#endif // DIRECTORY_CONFIG_H
/**
 * @file display_utils.c
 * @brief Utility functions for displaying directory entries
 *
 * This file contains functions for formatting and displaying
 * directory entries in a grid layout. It handles UTF-8 character
 * width calculations and Git status integration.
 *
 * @author Sergey Veneckiy
 * @date 2024
 */

#include <glob.h>
#include <stdio.h>
#include <wchar.h>
#include <string.h>
#include <stdlib.h>
#include <locale.h>

#include "file_card.h"
#include "git_utils.h"
#include "dir_config.h"
#include "display_utils.h"

#define MAX_COLUMNS 4
#define SPACING 2
#define EMOJI_WIDTH 2
#define EMOJI_NAME_SPACING 1

/**
 * @brief Calculate the width of a UTF-8 character
 *
 * @param str Pointer to the start of a UTF-8 character
 * @return Size of the UTF-8 character in bytes
 */
size_t get_utf8_char_width(const char *str) {
    unsigned char c = (unsigned char)*str;  // Get the first byte of the character
    if (c < 0x80) return 1;  // ASCII character (1 byte)
    if (c < 0xE0) return 2;  // 2-byte UTF-8 character
    if (c < 0xF0) return 3;  // 3-byte UTF-8 character
    return 4;  // 4-byte UTF-8 character
}

/**
 * @brief Calculate the display width of a UTF-8 string
 *
 * @param str The UTF-8 string to measure
 * @return Display width of the string
 */
size_t get_display_width(const char *str) {
    size_t width = 0;  // Initialize the display width
    while (*str) {  // Loop through each character in the string
        size_t char_width = get_utf8_char_width(str);  // Get the byte width of the current character
        if (char_width == 4) {
            width += 2;  // 4-byte UTF-8 characters are typically displayed as width 2
        } else if (char_width > 1) {
            width += 1;  // 2 and 3-byte UTF-8 characters are typically displayed as width 1
        } else {
            width += 1;  // ASCII characters have a width of 1
        }
        str += char_width;  // Move to the next character
    }
    return width;  // Return the total display width
}

/**
 * @brief Print a string with padding to a specified width
 *
 * @param str The string to print
 * @param width The desired total width
 */
void print_padded(const char *str, size_t width) {
    size_t str_width = get_display_width(str);  // Get the display width of the string
    printf("%s", str);  // Print the string
    for (size_t i = str_width; i < width; i++) {
        printf(" ");  // Add padding spaces
    }
}

/**
 * @brief Display directory entries in a grid layout
 *
 * @param entries Array of FileCardInfo structures
 * @param num_entries Number of entries in the array
 * @param term_width Width of the terminal
 * @param current_dir Current directory path
 * @param show_path Flag to determine if the path should be displayed
 */
void display_entries(FileCardInfo *entries, int num_entries, int term_width,
                     const char *current_dir, int show_path) {
    setlocale(LC_ALL, "");  // Set the locale for proper UTF-8 handling

    if (show_path) {
        char *branch = get_current_branch();  // Get the current Git branch
        if (branch) {
            printf("\033[1m%s\033[0m  \033[38;5;202m[%s]\033[0m\n", current_dir, branch);  // Print directory and branch
            free(branch);  // Free the allocated branch name
        } else {
            printf("\033[1m%s\033[0m\n", current_dir);  // Print directory without branch
        }
    }

    // Allocate memory for entry widths
    size_t *entry_widths = malloc(num_entries * sizeof(size_t));
    if (!entry_widths) {
        fprintf(stderr, "Memory allocation failed\n");
        return;
    }

    size_t max_width = 0;  // Track the maximum entry width
    for (int i = 0; i < num_entries; i++) {
        // Calculate the width of each entry
        entry_widths[i] = EMOJI_WIDTH + EMOJI_NAME_SPACING + get_display_width(entries[i].name);
        if (entries[i].git_status[0] != '\0' || (entries[i].is_directory && entries[i].contains_modified)) {
            entry_widths[i] += 3;  // Add space for Git status
        }
        if (entry_widths[i] > max_width) {
            max_width = entry_widths[i];  // Update maximum width
        }
    }

    // Calculate the number of columns based on terminal width
    int num_columns = (term_width + SPACING) / (max_width + SPACING);
    int max_columns = get_max_columns(current_dir);  // Get max columns for the current directory
    if (num_columns > max_columns) num_columns = max_columns;
    if (num_columns < 1) num_columns = 1;

    // Allocate memory for column widths
    size_t *column_widths = calloc(num_columns, sizeof(size_t));
    if (!column_widths) {
        fprintf(stderr, "Memory allocation failed\n");
        free(entry_widths);
        return;
    }

    int rows = (num_entries + num_columns - 1) / num_columns;  // Calculate number of rows

    // Determine the width of each column
    for (int i = 0; i < num_entries; i++) {
        int col = i / rows;
        if (entry_widths[i] > column_widths[col]) {
            column_widths[col] = entry_widths[i];
        }
    }

    // Display entries in a grid
    for (int row = 0; row < rows; row++) {
        for (int col = 0; col < num_columns; col++) {
            int index = col * rows + row;
            if (index < num_entries) {
                printf("%s ", entries[index].emoji);  // Print emoji
                printf("%s", entries[index].name);    // Print name

                // Print Git status if applicable
                if (entries[index].git_status[0] != '\0') {
                    printf("\033[38;5;202m[%c]\033[0m", entries[index].git_status[0]);
                } else if (entries[index].is_directory && entries[index].contains_modified) {
                    printf("\033[38;5;202m[+]\033[0m");
                }

                // Add padding to align columns
                size_t printed_width = entry_widths[index];
                size_t padding = (col < num_columns - 1) ? column_widths[col] - printed_width + SPACING : 0;
                for (size_t i = 0; i < padding; i++) {
                    printf(" ");
                }
            }
        }
        printf("\n");  // Move to the next row
    }

    free(entry_widths);    // Free allocated memory
    free(column_widths);   // Free allocated memory
}
#ifndef DISPLAY_UTILS_H
#define DISPLAY_UTILS_H

#include "file_card.h"

void display_entries(FileCardInfo *entries, int num_entries, int term_width,
                     const char *current_dir, int show_path);

#endif // DISPLAY_UTILS_H
/**
 * @file emoji_extensions.c
 * @brief Implementation of emoji mappings for various file types and attributes.
 *
 * This file contains the definitions of emoji mapping arrays for file extensions,
 * exact file names, file content patterns, and device files. These mappings are
 * used to assign appropriate emojis to files and directories based on their
 * characteristics.
 *
 * @author Sergey Veneckiy
 * @date 2024
 */

#include "emoji_mappings.h"

/**
 * @brief Emoji mappings for file extensions.
 *
 * This array maps file extensions to corresponding emojis. It is used to
 * assign emojis based on the file type indicated by its extension.
 */
const EmojiMapEntry emoji_extension_map[] = {
    {"md", "📑"},
    {"jpg", "📸"},
    {"jpeg", "📸"},
    {"png", "📸"},
    {"gif", "📸"},
    {"bmp", "📸"},
    {"svg", "📸"},
    {"webp", "📸"},
    {"mp4", "🎬"},
    {"avi", "🎬"},
    {"mkv", "🎬"},
    {"mov", "🎬"},
    {"flv", "🎬"},
    {"wmv", "🎬"},
    {"webm", "🎬"},
    {"mp3", "🎧"},
    {"wav", "🎧"},
    {"ogg", "🎧"},
    {"flac", "🎧"},
    {"m4a", "🎧"},
    {"aac", "🎧"},
    {"zip", "📦"},
    {"tar", "📦"},
    {"gz", "📦"},
    {"bz2", "📦"},
    {"xz", "📦"},
    {"7z", "📦"},
    {"rar", "📦"},
    {"xip", "📦"},
    {"deb", "📥"},
    {"rpm", "📥"},
    {"py", "🐍"},
    {"js", "🟡"},
    {"css", "🎨"},
    {"cpp", "🔬"},
    {"cc", "🔬"},
    {"cxx", "🔬"},
    {"cppm", "🔬"},
    {"c", "🔬"},
    {"java", "☕"},
    {"jar", "☕"},
    {"pak", "📦"},
    {"go", "🐹"},
    {"rb", "♦️ "},
    {"rs", "🦀"},
    {"php", "🐘"},
    {"h", "🧢"},
    {"hpp", "🧢"},
    {"hxx", "🧢"},
    {"xx", "🧢"},
    {"class", "☕"},
    {"kt", "💻"},
    {"scala", "♨️ "},
    {"jsx", "💻"},
    {"tf", "🏗️ "},
    {"tsx", "💻"},
    {"vue", "🟩"},
    {"dart", "🦋"},
    {"lua", "🌙"},
    {"pl", "🐪"},
    {"r", "📈"},
    {"m", "💻"},
    {"mm", "💻"},
    {"asm", "📟"},
    {"s", "📟"},
    {"f", "🅵"},
    {"f90", "🅵"},
    {"lisp", "💻"},
    {"hs", "λ "},
    {"ml", "🐫"},
    {"mli", "🐫"},
    {"clj", "🍃"},
    {"groovy", "💻"},
    {"jl", "💻"},
    {"ex", "⚗️ "},
    {"exs", "⚗️ "},
    {"elm", "💻"},
    {"coffee", "☕"},
    {"ts", "🔷"},
    {"d", "🅳 "},
    {"cs", "💻"},
    {"vb", "💻"},
    {"fs", "🔷"},
    {"fsx", "🔷"},
    {"sql", "🗄️ "},
    {"pas", "🏫"},
    {"lhs", "💻"},
    {"cob", "💻"},
    {"o", "🧩"},
    {"db", "🗄️ "},
    {"gem", "💎"},
    {"txt", "📝"},
    {"rst", "📝"},
    {"log", "🪵"},
    {"ttf", "🔤"},
    {"otf", "🔤"},
    {"woff", "🔤"},
    {"woff2", "🔤"},
    {"pdf", "📕"},
    {"djvu", "📗"},
    {"epub", "📙"},
    {"pem", "🔑"},
    {"crt", "🔑"},
    {"key", "🔑"},
    {"pub", "🔑"},
    {"p12", "🔑"},
    {"csv", "📊"},
    {"torrent", "🌊"},
    {"iso", "💽"},
    {"img", "💽"},
    {"qcow", "🐮"},
    {"qcow2", "🐮"},
    {"vv", "🕹️"},
    {"doc", "📄"},
    {"docx", "📄"},
    {"odt", "📄"},
    {"rtf", "📄"},
    {"xls", "📄"},
    {"xlsx", "📄"},
    {"ods", "📄"},
    {"ppt", "📄"},
    {"pptx", "📄"},
    {"odp", "📄"},
    {"conf", "⚙️ "},
    {"config", "⚙️ "},
    {"toml", "Ⓣ "},
    {"cfg", "⚙️ "},
    {"yaml", "🅈 "},
    {"yml", "🅈 "},
    {"json", "🏝️ "},
    {"jsonc", "🏝️ "},
    {"ini", "🎛️ "},
    {"target", "🎯"},
    {"service", "🚀"},
    {"socket", "🔌"},
    {"vim", "🖖"},
    {"blend", "🧈"},
    {"app", "📱"},
    {"dmg", "💿"},
    {"pkg", "📦"},
    {"patch", "🩹"},
    {"plist", "⚙️ "},
    {"scpt", "📜"},
    {"swift", "🐦"},
    {"xcodeproj", "🛠️"},
    {"mlmodel", "🧠"},
    {"arobject", "🎭"},
    {"cmake", "🏗️ "},
    {"mvn", "🏹"},
    {"html", "🌐"},
    {"xml", "🌐"},
    {"sks", "🎮"},
    {"car", "🚗"},
    {"xcassets", "🗂️"},
    {"dSYM", "🐛"},
    {"terminal", "🖥️"},
    {"lock", "🔒"},
    {"webloc", "🔗"},
    {"workflow", "🔄"},
    {"apk", "📱"},
    {"rc", "👟"},
    {"bundle", "🎁"},
    {"pb", "📋"},
    {"sock", "🧦"},
    {"tmp", "⏳"},
    {"ko", "🌰"},
    {"ccl", "🎨"},
    {"sh", "🐚"},
    {"bash", "💰"},
    {"fish", "🐟"},
    {"xib", "🖼️"},
    {"ninja", "🥷"},
    {"lisp", "λ"},
    {"cl", "λ"},
    {"lsp", "λ"},
    {"ada", "✈️"},
    {"adb", "✈️"},
    {"ads", "✈️"},
    {"zsh", "🆉 "},
    {"zsh-theme", "🆉 "},
    {"gradle", "🐘"},
    {"lock", "🔒"},
    {"mermaid", "🌊"},
    {"plantuml", "🌱"},
    {"dot", "📍"},
    {"drawio", "📉"},
    {"ipa", "📲"},
    {"mlmodel", "🤖"},
    {"icns", "🖼️ "},
    {"tif", "🖼️ "},
    {"framework", "🏗️ "},
    {"xcassets", "🗂️"},
    {"playground", "🎠"},
    {"part", "🧩"},
    {"diff", "🆚"},
    {"bak", "🔙"},
    {"cache", "⏱️"},
    {"desktop", "🖥️ "},
    {"cron", "📅"},
    {"env", "🌍"},
    {"bin", "💾"},
    {"so", "💾"},
    {"pid", "🪪"},
    {"swap", "🔄"},
    {"list", "📋"},
    {"nim", "👑"},
    {"rkt", "🏸"},
    {"deny", "⛔"},
    {"m4", "📻"},
    {"bazel", "🏗️ "},
    {"bzl", "🏗️ "},
    {"zig", "⚡️"},
    {"mk", "🔨"},
    {"xcf", "🖌️ "},
    {"pcm", "💾"},
    {"in", "🚪"},
    {"dsp", "🪟"},
    {"vcxproj", "🪟"},
    {"ico", "🪟"},
    {"ctags", "🏷️"},
    {"awk", "✂️"},
    {"sed", "✂️"},
    {"zst", "🗜️ "},
    {"initramfs", "🛫"},
    {"proto", "📡"},
    {"data", "🔢"},
    {"vala", "🦋"},
    {"vapi", "🦋"},
    {"ui", "🖌️ "},
    {"idx", "📇"},
    {"rev", "🔄"},
    {"pack", "🗜️"},
    {"mo", "🗣️ "},
    {"pf2", "🔠"},
    {"lst", "📜"},
    {"mod", "🧩"},
    {"cocci", "🐞"},
    {"Dockerfile", "🐳"},
    {"csproj", "🔨"},
    {"vcxproj", "🔨"},
    {"vbproj", "🔨"},
    {"fsproj", "🔨"},
    {"pbxproj", "🔨"},
    {"pro", "🔨"},
    {"cbp", "🔨"},
    {"cproject", "🔨"},
    {"dproj", "🔨"},
    {"cbproj", "🔨"},
    {"sum", "🧮"},
    {"nix", "❄️ "},
    {"mjs", "🟡"},
    {"nuspec", "⚙️ "},
    {"iml", "🧩"},
    {"erl", "🟥"},
    {"dump", "🛢️"},
    {"beam", "🔦"},
    {"vhdl", "🧠"},
    {"xdc", "⛓"},
    {"gtkw", "👁️"},
    {"v", "⚡"},
    {"vhd", "📜"},
    {"hex", "📟"},
    {"hash", "🖊️ "},
    {"exr", "🏋️"},
    {"hdr", "🌌"},
    {"psd", "🖌️"},
    {"fossil", "🦎"},
    {"svn", "🆂"},
    {"hg", "☿"}
};

/** @brief Size of the emoji_extension_map array. */
const size_t emoji_extension_map_size = sizeof(emoji_extension_map) /
                                        sizeof(emoji_extension_map[0]);

/**
 * @brief Emoji mappings for exact file names.
 *
 * This array maps specific file names to corresponding emojis. It is used to
 * assign emojis based on exact matches of file names, typically for special files.
 */
const EmojiMapEntry emoji_exact_file_map[] = {
    {"shadow", "🕶️"},
    {"shadow-", "🔙"},
    {"fstab", "⬜"},
    {"Makefile.am", "🏗️ "},
    {"configure.ac", "🏗️ "},
    {"CmakeLists.txt", "🏗️ "},
    {"meson.build", "🏗️ "},
    {"meson_options.txt", "🏗️ "},
    {"WORKSPACE", "🏗️ "},
    {".bazelrc", "🏗️ "},
    {"Makefile.in", "🏗️ "},
    {"configure.ac", "🏗️ "},
    // {".gitignore", "🙈"},
    // {".dockerignore", "🙈"},
    // {".hgignore", "🙈"},
    // {".npmignore", "🙈"},
    // {".bzrignore", "🙈"},
    // {".eslintignore", "🙈"},
    // {".terraformignore", "🙈"},
    // {".prettierignore", "🙈"},
    // {".clang-format-ignore", "🙈"},
    // {".p4ignore", "🙈"},
    // {".bazelignore", "🙈"},
    // {".stylelintignore", "🙈"},
    // {".trackerignore", "🙈"},
    // {".yapfignore", "🙈"},
    {"Dockerfile", "🐳"},
    {"Dockerfile.txt", "🐳"},
    {".gitlab-ci.yml", "🦊"},
    {".travis.yml", "⛑️"},
    {"swagger.yaml", "🧣"},
    {"Jenkinsfile", "🔴"},
    {"tags", "🏷️ "},
    {".hgtags", "🏷️ "},
    //{"LICENSE", "⚖️ "},
    //{"LICENSE.TXT", "⚖️ "},
    //{"LICENSE.txt", "⚖️ "},
    {"COPYING", "⚖️ "},
    {"COPYING.LIB", "⚖️ "},
    //{"LICENSE-docs", "⚖️ "},
    {"APACHE2", "⚖️ "},
    //{"LICENSE-APACHE2", "⚖️ "},
    {".ninja_deps", "🥷"},
    {".ninja_log", "🥷"},
    {".gitattributes", "🐙"},
    {".gitconfig", "🐙"},
    {".gitmodules", "🐙"},
    {".git-blame-ignore-revs", "🐙"},
    {".gitkeep", "🐙"},
    {".gitallowed", "🐙"},
    {".zcompdump", "🆉 "},
    {".zprofile", "🆉 "},
    {".zshrc", "🆉 "},
    {".histfile", "🆉 "},
    {".bashrc", "💰"},
    {".bash_history", "💰"},
    {".bash_logout", "💰"},
    {".bash_profile", "💰"},
    {".prettierrc", "🖌️ "},
    {".inputrc", "🖮 "},
    {".vimrc", "🖖"},
    {".viminfo", "🖖"},
    {".clang-tidy", "🧹"},
    {".clang-format", "🧹"},
    {".clangd", "🧹"},
    {".babelrc", "🗼"},
    {"manifest.txt", "📜"},
    {"robots.txt", "🕷️"},
    {"sitemap.txt", "🗺️"},
    {"Pipfile.txt", "🐍"},
    {"requirements.txt", "🧾"},
    {".editorconfig", "📐"},
    {"tsconfig.json", "🔷"},
    {"tsconfig.test.json", "🧪"},
    {"jest.config.js", "🧪"},
    {"php.ini", "🐘"},
    {"dnsmasq.conf", "🌐"},
    {"vimrc", "🖖"},
    {"virc", "🖖"},
    {"profile", "🚪"},
    {"libuser.conf", "👤"},
    {"subuid", "👤"},
    {"subuid-", "🔙"},
    {"pinforc", "📌"},
    {"sudoers", "👑"},
    {"sudo.conf", "👑"},
    {"man_db.conf", "📖"},
    {"chrony.conf", "⏰"},
    {"group", "👥"},
    {"group-", "🔙"},
    {"zshenv", "🆉 "},
    {"zlogin", "🆉 "},
    {"zlogout", "🆉 "},
    {"zshrc", "🆉 "},
    {"zprofile", "🆉 "},
    {"inittab", "🚀"},
    {"netconfig", "🌐"},
    {"hosts", "🏠"},
    {"login.defs", "🪵"},
    {"logrotate.conf", "🪵"},
    {"rsyslog.conf", "🪵"},
    {"aliases", "🔀"},
    {"dnsmasq.conf", "🎭"},
    {"kdump.conf", "🚛"},
    {"makedumpfile.conf.sample", "🚛"},
    {"subgid", "👥"},
    {"subgid-", "🔙"},
    {"ts.conf", "👆"},
    {"krb5.conf", "🎟️"},
    {"xattr.conf", "🏷️"},
    {"mke2fs.conf", "🌱"},
    {"sysctl.conf", "🎛️ "},
    {"opensc.conf", "💳"},
    {"whois.conf", "🕵️"},
    {"sddm.conf", "🖥️ "},
    {"asound.conf", "🔊"},
    {"passim.conf", "📡"},
    {"vdpau_wrapper.cfg", "🎞️"},
    {"Trolltech.conf", "🔨"},
    {"npmrc", "📦"},
    {"nilfs_cleanerd.conf", "🧹"},
    {"sensors3.conf", "🌡️"},
    {"brltty.conf", "👓"},
    {"magic", "🎩"},
    {"swtpm-localca.options", "🔐"},
    {"filesystems", "🌳"},
    {"passwd", "🛡️"},
    {"passwd-", "🔙"},
    {"bashrc", "💰"},
    {"crontab", "📅"},
    {"Gemfile", "💎"},
    {"Cargo.toml", "🛻"},
    {".eslintrc", "🧹"},
    {"tox.ini", "🧪"},
    {"rsyncd.conf", "🔁"},
    {".cocciconfig", "🐞"},
    {".gdbinit", "🐠"},
    {".flake8", "🥣"},
    {".mailmap", "📧"},
    {"gradle.properties", "🐘"},
    {"build.gradle.kts", "🐘"},
    {".flowconfig", "🧹"},
    {"Doxyfile", "🕮 "},
    {"AUTHORS", "📝"},
    {"index", "📌"},
    {"perf.data", "⏱️"},
    {"perf.data.old", "⏱️"},
    //{"", ""},
};
/** @brief Size of the emoji_exact_file_map array. */
const size_t emoji_exact_file_map_size = sizeof(emoji_exact_file_map) /
                                         sizeof(emoji_exact_file_map[0]);

/**
 * @brief Emoji mappings for not-exact file names.
 *
 * This array maps substring in file names to corresponding emojis. It is used to
 * assign emojis based on not-exact matches of file names, typically for special files.
 */
const EmojiMapEntry emoji_not_exact_file_map[] = {
    {"vmlinuz", "🐧"},
    {"initrd", "🌀"},
    {"System.map", "🗺️ "},
    {"bazel", "🏗️ "},
    {"pylint", "🧪"},
    {"grub", "🥾"},
    {"Kbuild", "🏗️ "},
    {"Kconfig", "🧭"},
    {"Makefile", "🔨"},
    {"ignore", "🙈"},
    {"LICENSE", "⚖️ "},
};

/** @brief Size of the emoji_not_exact_file_map array. */
const size_t emoji_not_exact_file_map_size = sizeof(emoji_not_exact_file_map) /
                                         sizeof(emoji_not_exact_file_map[0]);

/**
 * @brief Emoji mappings for file content patterns.
 *
 * This array maps file content patterns (typically shebang lines) to corresponding emojis.
 * It is used to assign emojis based on the content of script files.
 */
const EmojiMapEntry emoji_file_content_map[] = {
    {"#!/bin/sh", "🐚"},
    {"#!/usr/bin/sh", "🐚"},
    {"#!/usr/bin/env sh", "🐚"},
    {"#!/bin/bash", "💰"},
    {"#!/usr/bin/bash", "💰"},
    {"#!/usr/bin/env bash", "💰"},
    {"#!/bin/dash", "🐚"},
    {"#!/usr/bin/dash", "🐚"},
    {"#!/usr/bin/env dash", "🐚"},
    {"#!/bin/zsh", "🆉 "},
    {"#!/usr/bin/zsh", "🆉 "},
    {"#!/usr/bin/env zsh", "🆉 "},
    {"#!/bin/ksh", "🐚"},
    {"#!/usr/bin/ksh", "🐚"},
    {"#!/usr/bin/env ksh", "🐚"},
    {"#!/usr/bin/perl", "🐪"},
    {"#!/usr/bin/perl5", "🐪"},
    {"#!/usr/local/bin/perl", "🐪"},
    {"#!/usr/bin/env perl", "🐪"},
    {"#!/usr/bin/env perl5", "🐪"},
    {"#!/opt/bin/perl", "🐪"},
    {"#!/bin/ruby", "♦️"},
    {"#!/usr/bin/ruby", "♦️"},
    {"#!/usr/local/bin/ruby", "♦️"},
    {"#!/usr/bin/env ruby", "♦️"},
    {"#!/opt/local/bin/ruby", "♦️"},
    {"#!/usr/bin/python", "🐍"},
    {"#!/usr/bin/python2", "🐍"},
    {"#!/usr/bin/python3", "🐍"},
    {"#!/usr/local/bin/python", "🐍"},
    {"#!/usr/bin/env python", "🐍"},
    {"#!/usr/bin/env python2", "🐍"},
    {"#!/usr/bin/env python3", "🐍"},
    {"#!/usr/bin/lua", "🌙"},
    {"#!/usr/local/bin/lua", "🌙"},
    {"#!/usr/bin/env lua", "🌙"},
    {"#!/usr/bin/tcl", "☯️"},
    {"#!/usr/local/bin/tcl", "☯️"},
    {"#!/usr/bin/env tcl", "☯️"},
    {"#!/usr/bin/awk", "🐦"},
    {"#!/usr/bin/awk -f", "🐦"},
    {"#!/usr/local/bin/awk", "🐦"},
    {"#!/usr/bin/env awk", "🐦"},
    {"#!/usr/bin/gawk", "🐦"},
    {"#!/usr/bin/env gawk", "🐦"},
    {"#!/usr/bin/node", "💚"},
    {"#!/usr/local/bin/node", "💚"},
    {"#!/usr/bin/env node", "💚"},
    {"#!/usr/bin/nodejs", "💚"},
    {"#!/usr/bin/env nodejs", "💚"},
    {"#!/usr/bin/php", "🐘"},
    {"#!/usr/local/bin/php", "🐘"},
    {"#!/usr/bin/env php", "🐘"},
    {"#!/usr/bin/fish", "🐟"},
    {"#!/usr/local/bin/fish", "🐟"},
    {"#!/usr/bin/env fish", "🐟"}
};
/** @brief Size of the emoji_file_content_map array. */
const size_t emoji_file_content_map_size = sizeof(emoji_file_content_map) /
                                           sizeof(emoji_file_content_map[0]);


/**
 * @brief Emoji mappings for exact device file names in /dev.
 *
 * This array maps specific device file names in the /dev directory to corresponding emojis.
 * It is used to assign emojis to known device files.
 */
const EmojiMapEntry emoji_exact_dev_file_map[] = {
    {"loop", "🔁"},
    {"null", "🕳️ "},
    {"zero", "🕳️ "},
    {"random", "🎲"},
    {"urandom", "🎲"},
    {"usb", "🔌"},
    {"vga_arbiter", "🖼️ "},
    {"vhci", "🔌"},
    {"vhost-net", "🌐"},
    {"vhost-vsock", "💬"},
    {"mcelog", "📋"},
    {"media0", "🎬"},
    {"mei0", "🧠"},
    {"mem", "🗄️ "},
    {"hpet", "⏱️"},
    {"hwrng", "🎲"},
    {"kmsg", "📜"},
    {"kvm", "🌰"},
    {"zram", "🗜️"},
    {"udmabuf", "🔄"},
    {"uhid", "🕹️"},
    {"rfkill", "📡"},
    {"ppp", "🌐"},
    {"ptmx", "🖥️ "},
    {"userfaultfd", "🚧"},
    {"nvram", "🗄️ "},
    {"port", "🔌"},
    {"autofs", "🚗"},
    {"btrfs-control", "🌳"},
    {"console", "🖥️ "},
    {"full", "🔒"},
    {"fuse", "🔥"},
    {"gpiochip0", "📌"},
    {"cuse", "🧩"},
    {"cpu_dma_latency", "⏱️"},
};
/** @brief Size of the emoji_exact_dev_file_map array. */
const size_t emoji_exact_dev_file_map_size = sizeof(emoji_exact_dev_file_map) /
                                             sizeof(emoji_exact_dev_file_map[0]);

/**
 * @brief Emoji mappings for device file name prefixes in /dev.
 *
 * This array maps prefixes of device file names in the /dev directory to corresponding emojis.
 * It is used to assign emojis to device files based on their name prefixes.
 */
const EmojiMapEntry emoji_prefix_dev_map[] = {
    {"loop", "🔁"},
    {"sd", "💽"},
    {"tty", "🖥️ "},
    {"usb", "🔌"},
    {"video", "🎥"},
    {"nvme", "💽"},
    {"lp", "🖨️"},
    {"hidraw", "⌨️ "},
    {"vcs", "📟"},
    {"vcsa", "📟"},
    {"ptp", "🕰️ "},
    {"rtc", "🕰️ "},
    {"watchdog", "🐕"},
    {"mtd", "⚡"},
    //{"ttyACM", "♾️ "},
    {"i2c", "🚌"},
    {"dm-", "🧳"},
    {"vhost", "🛗"},

};

/** @brief Size of the emoji_prefix_dev_map array. */
const size_t emoji_prefix_dev_map_size = sizeof(emoji_prefix_dev_map) /
                                         sizeof(emoji_prefix_dev_map[0]);
/**
 * @file emoji_extensions.h
 * @brief Definitions and declarations for emoji mappings.
 *
 * This header file defines the structure for emoji mappings and declares
 * arrays of mappings for various file types, extensions, and special cases.
 * These mappings are used to assign appropriate emojis to files and directories
 * based on their characteristics.
 *
 * @author Sergey Veneckiy
 * @date 2024
 */

#ifndef EMOJI_EXTENSIONS_H
#define EMOJI_EXTENSIONS_H

#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @struct EmojiMapEntry
 * @brief Structure to map keys (file names or extensions) to emojis.
 */
typedef struct {
    const char *key;   /**< The key (file name, extension, or content pattern) */
    const char *emoji; /**< The corresponding emoji */
} EmojiMapEntry;

/**
 * @brief Array of emoji mappings for file extensions.
 *
 * This array contains mappings of file extensions to their corresponding emojis.
 */
extern const EmojiMapEntry emoji_extension_map[];

/**
 * @brief Size of the emoji_extension_map array.
 */
extern const size_t emoji_extension_map_size;

/**
 * @brief Array of emoji mappings for exact file names.
 *
 * This array contains mappings of specific file names to their corresponding emojis.
 */
extern const EmojiMapEntry emoji_exact_file_map[];

/**
 * @brief Size of the emoji_exact_file_map array.
 */
extern const size_t emoji_exact_file_map_size;

/**
* @brief Array of emoji mappings for not-exact file names.
*
* This array contains mappings of specific file names to their corresponding emojis.
*/
extern const EmojiMapEntry emoji_not_exact_file_map[];

/**
* @brief Size of the emoji_not_exact_file_map array.
*/
extern const size_t emoji_not_exact_file_map_size;

/**
 * @brief Array of emoji mappings for file content patterns.
 *
 * This array contains mappings of file content patterns (e.g., shebangs) to their corresponding emojis.
 */
extern const EmojiMapEntry emoji_file_content_map[];

/**
 * @brief Size of the emoji_file_content_map array.
 */
extern const size_t emoji_file_content_map_size;

/**
 * @brief Array of emoji mappings for exact device file names in /dev.
 *
 * This array contains mappings of specific device file names to their corresponding emojis.
 */
extern const EmojiMapEntry emoji_exact_dev_file_map[];

/**
 * @brief Size of the emoji_exact_dev_file_map array.
 */
extern const size_t emoji_exact_dev_file_map_size;

/**
 * @brief Array of emoji mappings for device file name prefixes in /dev.
 *
 * This array contains mappings of device file name prefixes to their corresponding emojis.
 */
extern const EmojiMapEntry emoji_prefix_dev_map[];

/**
 * @brief Size of the emoji_prefix_dev_map array.
 */
extern const size_t emoji_prefix_dev_map_size;

#ifdef __cplusplus
}
#endif

#endif /* EMOJI_EXTENSIONS_H */
/**
 * @file emoji_utils.c
 * @brief Implementation of emoji utility functions for file representation
 *
 * This file contains functions for determining appropriate emojis
 * for files based on their types, attributes, and locations. It supports
 * both regular files and special files in the /dev directory.
 *
 * @author Sergey Veneckiy
 * @date 2024
 */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

#include "emoji_utils.h"
#include "emoji_mappings.h"

#define MAX_PATH 4096

/**
 * @brief Safely duplicates a string, handling memory allocation errors
 *
 * @param str The string to duplicate
 * @return A newly allocated copy of the input string
 */
static char *safe_strdup(const char *str) {
    char *dup = strdup(str);
    if (!dup) {
        perror("strdup"); // Print error message if strdup fails
        exit(EXIT_FAILURE); // Exit the program on allocation failure
    }
    return dup;
}

/**
 * @brief Determines the appropriate emoji for files in the /dev directory
 *
 * @param path The name of the file in the /dev directory
 * @return A dynamically allocated string containing the emoji
 */
char *get_dev_emoji(const char *path) {
    // Check for prefix matches in the dev prefix map
    for (size_t i = 0; i < emoji_prefix_dev_map_size; i++) {

        if (strstr(path, "ttyACM") != NULL) {
            return safe_strdup("♾️ ");
        }

        if (strncmp(path, emoji_prefix_dev_map[i].key, strlen(emoji_prefix_dev_map[i].key)) == 0) {
            return safe_strdup(emoji_prefix_dev_map[i].emoji);
        }
    }

    // Check for exact matches in the dev file map
    for (size_t i = 0; i < sizeof(emoji_exact_dev_file_map_size); i++) {
        if (strcmp(path, emoji_exact_dev_file_map[i].key) == 0) {
            return safe_strdup(emoji_exact_dev_file_map[i].emoji);
        }
    }

    // Return default emoji for unmatched /dev files
    return safe_strdup("🔧");
}

/**
 * @brief Checks the file content for specific patterns to determine the file type
 *
 * @param path The path to the file
 * @return A dynamically allocated string containing the emoji, or NULL if no match
 */
static char* check_file_content(const char *path) {
    FILE *file = fopen(path, "r");
    if (!file) return NULL;

    char buffer[256];
    if (fgets(buffer, sizeof(buffer), file) != NULL) {
        // Check each entry in the file content map
        for (size_t i = 0; i < emoji_file_content_map_size; i++) {
            if (strstr(buffer, emoji_file_content_map[i].key) != NULL) {
                fclose(file);
                return safe_strdup(emoji_file_content_map[i].emoji);
            }
        }
    }

    fclose(file);
    return NULL;
}

/**
 * @brief Determines the appropriate emoji for a given file based on its characteristics
 *
 * @param path The path to the file
 * @return A dynamically allocated string containing the emoji
 */
char *get_emoji(const char *path) {
   struct stat path_stat;

    // Check if we can get file information
    if (lstat(path, &path_stat) != 0) {
        return safe_strdup("❓");  // Unknown file type
    }

    // Check for symbolic links
    if (S_ISLNK(path_stat.st_mode)) {
        return safe_strdup(S_ISDIR(path_stat.st_mode) ? "🔗📁" : "🔗");
    }

    // Check for directories
    if (S_ISDIR(path_stat.st_mode)) {
        return safe_strdup("📁");
    }

    // Extract the filename from the path
    const char *filename = strrchr(path, '/');
    filename = filename ? filename + 1 : path;

    // Check for not-exact file name matches first (top highest priority)
    for (size_t i = 0; i < emoji_not_exact_file_map_size; i++) {
        if (strstr(filename, emoji_not_exact_file_map[i].key) != NULL) {
            return safe_strdup(emoji_not_exact_file_map[i].emoji);
        }
    }

    // Check for exact file name matches first (highest priority)
    for (size_t i = 0; i < emoji_exact_file_map_size; i++) {
        if (strcasecmp(filename, emoji_exact_file_map[i].key) == 0) {
            return safe_strdup(emoji_exact_file_map[i].emoji);
        }
    }

    // Check file content for specific patterns (second priority)
    char *content_emoji = check_file_content(path);
    if (content_emoji) {
        return content_emoji;
    }

    // Check file extensions (third priority)
    char *extension = strrchr(filename, '.');
    if (extension) {
        extension++;  // Skip the dot
        for (size_t i = 0; i < emoji_extension_map_size; i++) {
            if (strcasecmp(extension, emoji_extension_map[i].key) == 0) {
                return safe_strdup(emoji_extension_map[i].emoji);
            }
        }
    }

    // Check for hidden files
    if (filename[0] == '.') {
        return safe_strdup("⚙️ ");
    }

    // Check for executable files
    if (is_executable(path)) {
        return safe_strdup("💾");
    }

    // Check for text files
    if (is_text_file(path)) {
        return safe_strdup("📝");
    }

    // Default emoji for unclassified files
    return safe_strdup("❓");
}

/**
 * @brief Checks if a file is executable
 *
 * @param path The path to the file
 * @return 1 if the file is executable, 0 otherwise
 */
int is_executable(const char *path) {
    struct stat st;
    if (stat(path, &st) == 0) {
        return (st.st_mode & S_IXUSR) != 0; // Check if the user execute bit is set
    }
    return 0;
}

/**
 * @brief Checks if a file is a text file by examining its contents
 *
 * @param path The path to the file
 * @return 1 if the file is likely a text file, 0 otherwise
 */
int is_text_file(const char *path) {
    FILE *file = fopen(path, "rb");
    if (!file) {
        return 0; // Cannot open file, assume it's not text
    }

    unsigned char buffer[1024];
    size_t bytesRead = fread(buffer, 1, sizeof(buffer), file);
    fclose(file);

    if (bytesRead == 0) {
        return 1;  // Empty file is considered text
    }

    // Check if all read bytes are printable or whitespace
    for (size_t i = 0; i < bytesRead; i++) {
        if (!isprint(buffer[i]) && !isspace(buffer[i])) {
            return 0; // Non-printable, non-whitespace character found
        }
    }
    return 1; // All characters are printable or whitespace
}
/**
 * @file emoji_utils.h
 * @brief Utility functions for assigning emojis to files and directories.
 *
 * This header file declares functions for determining appropriate emojis
 * based on file types, attributes, and locations. It supports both regular
 * files and special files in the /dev directory.
 *
 * @author Sergey Veneckiy
 * @date 2024
 */

#ifndef EMOJI_UTILS_H
#define EMOJI_UTILS_H

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Determines the appropriate emoji for a given file path.
 *
 * This function analyzes the file at the given path and returns an emoji
 * representing its type (e.g., directory, text file, image, etc.).
 *
 * @param path The file path to analyze.
 * @return A dynamically allocated string containing the emoji.
 *         The caller is responsible for freeing this memory.
 */
char *get_emoji(const char *path);

/**
 * @brief Checks if a file is executable.
 *
 * This function determines whether the file at the given path has
 * execute permissions.
 *
 * @param path The file path to check.
 * @return 1 if the file is executable, 0 otherwise.
 */
int is_executable(const char *path);

/**
 * @brief Checks if a file is a text file.
 *
 * This function analyzes the content of the file to determine if it's
 * likely to be a text file.
 *
 * @param path The file path to check.
 * @return 1 if the file is likely a text file, 0 otherwise.
 */
int is_text_file(const char *path);

/**
 * @brief Determines the appropriate emoji for a device file in the /dev directory.
 *
 * This function analyzes the name of a file in the /dev directory and returns
 * an emoji representing its device type.
 *
 * @param path The file name in the /dev directory to analyze.
 * @return A dynamically allocated string containing the emoji.
 *         The caller is responsible for freeing this memory.
 */
char *get_dev_emoji(const char *path);

#ifdef __cplusplus
}
#endif

#endif /* EMOJI_UTILS_H */
/**
 * @file file_card.c
 * @brief Implementation of file card handling functions.
 *
 * This file contains functions for creating, freeing, and comparing file entries,
 * as well as utility functions for working with file names and extensions.
 * It provides the core functionality for managing file information in the facad tool.
 *
 * @author Sergey Veneckiy
 * @date 2024
 */

#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <ctype.h>

#include "emoji_utils.h"
#include "file_card.h"

/**
 * @brief Creates a new file card based on the given path.
 *
 * This function initializes a FileCardInfo structure with information about the file,
 * including its name, emoji representation, and flags for directory and hidden status.
 *
 * @param entry Pointer to a FileCardInfo structure to be filled.
 * @param path Path of the file to analyze.
 * @return 0 on success, -1 on error.
 */
int create_file_entry(FileCardInfo *entry, const char *path)
{
    // Duplicate the file name and store it in the entry
    entry->name = strdup(path);
    // Get the appropriate emoji for the file
    entry->emoji = get_emoji(path);

    struct stat path_stat;
    // Get file status information
    if (lstat(path, &path_stat) != 0)
    {
        return -1;  // Return -1 if unable to get file status
    }

    // Set directory flag based on file type
    entry->is_directory = S_ISDIR(path_stat.st_mode);
    // Set hidden flag if the file name starts with a dot
    entry->is_hidden = (path[0] == '.');
    // Initialize Git status as empty
    entry->git_status[0] = '\0';
    entry->git_status[1] = '\0';

    return 0;  // Return 0 on success
}

/**
 * @brief Frees memory allocated for a file entry.
 *
 * This function releases the memory allocated for the name and emoji fields
 * of a FileCardInfo structure.
 *
 * @param entry Pointer to the FileCardInfo structure to free.
 */
void free_file_entry(FileCardInfo *entry)
{
    free(entry->name);  // Free the memory allocated for the name string
    free(entry->emoji); // Free the memory allocated for the emoji string
}

/**
 * @brief Extracts the file extension from a filename.
 *
 * This function finds the last occurrence of a dot in the filename and
 * returns the substring following it as the file extension.
 *
 * @param name The filename to analyze.
 * @return A pointer to the file extension, or an empty string if no extension is found.
 */
char *get_extension(const char *name)
{
    char *dot = strrchr(name, '.'); // Find the last occurrence of '.'
    if (!dot || dot == name)
    {              // If no '.' found or it's the first character
        return ""; // Return empty string (no extension)
    }
    return dot + 1; // Return pointer to character after the last '.'
}

/**
 * @brief Compare two strings case-insensitively.
 *
 * This function provides a case-insensitive string comparison,
 * similar to strcasecmp, but implemented for portability.
 *
 * @param a The first string to compare.
 * @param b The second string to compare.
 * @return An integer less than, equal to, or greater than zero if a is found,
 *         respectively, to be less than, to match, or be greater than b.
 */
static int strcasecmp_wrapper(const char *a, const char *b) {
    // Loop continues as long as both strings have characters
    while (*a && *b) {
        // Convert current characters to lowercase for case-insensitive comparison
        int ca = tolower((unsigned char)*a);
        int cb = tolower((unsigned char)*b);

        // If characters differ, return their difference (determines sorting order)
        if (ca != cb) return ca - cb;

        // Move to the next character in both strings
        a++;
        b++;
    }

    // If we've reached here, one string might be longer than the other
    // Compare the last characters (one might be '\0' if strings are different lengths)
    return tolower((unsigned char)*a) - tolower((unsigned char)*b);
}

/**
 * @brief Compare two file entries for sorting.
 *
 * This function implements the sorting logic for file entries:
 * 1. Directories before files
 * 2. Within directories and files, dotfiles (hidden) before non-dotfiles
 * 3. Files sorted by extension
 * 4. Alphabetical sorting within the same type and extension
 *
 * @param a Pointer to the first FileCardInfo structure.
 * @param b Pointer to the second FileCardInfo structure.
 * @return An integer less than, equal to, or greater than zero if a is found,
 *         respectively, to be less than, to match, or be greater than b.
 */
int compare_file_entries(const void *a, const void *b)
{
    const FileCardInfo *entry_a = (const FileCardInfo *)a;
    const FileCardInfo *entry_b = (const FileCardInfo *)b;

    // Sort directories before files
    if (entry_a->is_directory != entry_b->is_directory) {
        return entry_b->is_directory - entry_a->is_directory;
    }

    // For directories, sort dotfiles first
    if (entry_a->is_directory && entry_b->is_directory) {
        // Check if one is a dotfile and the other isn't
        if ((entry_a->name[0] == '.') != (entry_b->name[0] == '.')) {
            return (entry_b->name[0] == '.') - (entry_a->name[0] == '.');
        }
        // Both are either dotfiles or non-dotfiles, sort alphabetically
        return strcasecmp_wrapper(entry_a->name, entry_b->name);
    }

    // For files, sort dotfiles first
    if ((entry_a->name[0] == '.') != (entry_b->name[0] == '.')) {
        return (entry_b->name[0] == '.') - (entry_a->name[0] == '.');
    }

    // Sort files by extension
    const char *ext_a = get_extension(entry_a->name);
    const char *ext_b = get_extension(entry_b->name);
    int ext_cmp = strcasecmp_wrapper(ext_a, ext_b);

    // If extensions differ, return their comparison result
    if (ext_cmp != 0) {
        return ext_cmp;
    }

    // If extensions are the same, sort alphabetically by name
    return strcasecmp_wrapper(entry_a->name, entry_b->name);
}
/**
 * @file file_card.h
 * @brief Definitions and functions for handling file entries
 *
 * This header file defines the FileCardInfo structure and declares
 * functions for creating, freeing, and comparing file entries. It
 * provides the core data structure and operations used throughout
 * the facad directory listing tool.
 *
 * @author Sergey Veneckiy
 * @date 2024
 */

#ifndef FILE_ENTRY_H
#define FILE_ENTRY_H

/**
 * @struct FileCardInfo
 * @brief Represents information about a file or directory entry
 *
 * This structure contains various attributes of a file or directory,
 * including its name, emoji representation, flags for directory and
 * hidden status, Git status, and a flag for modified contents.
 */
typedef struct
{
    char *name;              /**< Name of the file or directory */
    char *emoji;             /**< Emoji representation of the file type */
    int is_directory;        /**< Flag indicating if the entry is a directory (1) or file (0) */
    int is_hidden;           /**< Flag indicating if the entry is hidden (1) or visible (0) */
    char git_status[2];      /**< Git status of the file (2 characters for status code) */
    int contains_modified;   /**< Flag indicating if a directory contains modified files (1) or not (0) */
} FileCardInfo;

/**
 * @brief Creates a new file entry based on the given path
 *
 * This function initializes a FileCardInfo structure with information
 * about the file or directory at the specified path.
 *
 * @param entry Pointer to a FileCardInfo structure to be filled
 * @param path Path of the file or directory to analyze
 * @return 0 on success, -1 on error
 */
int create_file_entry(FileCardInfo *entry, const char *path);

/**
 * @brief Frees memory allocated for a file entry
 *
 * This function releases the memory allocated for the name and emoji
 * fields of a FileCardInfo structure.
 *
 * @param entry Pointer to the FileCardInfo structure to free
 */
void free_file_entry(FileCardInfo *entry);

/**
 * @brief Compares two file entries for sorting
 *
 * This function implements the sorting logic for file entries:
 * 1. Directories before files
 * 2. Within directories and files, dotfiles (hidden) before non-dotfiles
 * 3. Files sorted by extension
 * 4. Alphabetical sorting within the same type and extension
 *
 * @param a Pointer to the first FileCardInfo structure
 * @param b Pointer to the second FileCardInfo structure
 * @return An integer less than, equal to, or greater than zero if a is found,
 *         respectively, to be less than, to match, or be greater than b
 */
int compare_file_entries(const void *a, const void *b);

#endif // FILE_ENTRY_H
/**
 * @file git_integration.c
 * @brief Integration of Git status information with directory listing
 *
 * This file contains functions to integrate Git status information
 * into the file entries displayed by the facad tool. It handles
 * checking for modified files in directories and updating file
 * entry structures with Git status data.
 *
 * @author Sergey Veneckiy
 * @date 2024
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <dirent.h>
#include <sys/stat.h>

#include "git_integration.h"
#include "git_utils.h"

#define MAX_PATH 4096

/**
 * @brief Check if a directory contains modified files according to Git
 *
 * @param dir_path The path to the directory to check
 * @return int 1 if the directory contains modified files, 0 otherwise
 */
static int has_modified_files(const char* dir_path) {
    char command[MAX_PATH * 3];  // Buffer to store the Git command
    char full_path[MAX_PATH];    // Buffer to store the full path of the directory

    // Get the absolute path of the directory
    if (realpath(dir_path, full_path) == NULL) {
        return 0;  // Return 0 if unable to get the real path
    }

    // Construct the Git command to check for modifications
    // The command checks the status of files in the specified directory
    snprintf(command, sizeof(command),
             "git -C \"%s\" status --porcelain \"%s\" 2>/dev/null | grep -q '^\\s*[MADRCU]'",
             full_path, full_path);

    // Execute the command and return the result
    // system() returns 0 if the command was successful (i.e., modifications found)
    return system(command) == 0;
}

/**
 * @brief Integrate Git status information into file entries
 *
 * This function updates the FileCardInfo structures with Git status
 * information for each entry. It also checks directories for modified files.
 *
 * @param entries Pointer to an array of FileCardInfo pointers
 * @param num_entries Pointer to the number of entries in the array
 * @param current_dir The current directory path
 */
void integrate_git_status(FileCardInfo** entries, int* num_entries, const char* current_dir) {
    // Check if the current directory is a Git repository
    if (!is_git_repository()) {
        return;  // If not, return without doing anything
    }

    // Get the Git status for all files in the repository
    GitFileList git_status = get_git_status();

    // Iterate through all file entries
    for (int i = 0; i < *num_entries; i++) {
        // Reset Git status and modified flag for each entry
        (*entries)[i].git_status[0] = '\0';
        (*entries)[i].git_status[1] = '\0';
        (*entries)[i].contains_modified = 0;

        // Check Git status for files
        for (int j = 0; j < git_status.count; j++) {
            // If the file name matches a file in the Git status list
            if (strcmp((*entries)[i].name, git_status.files[j].filename) == 0) {
                // Set the Git status for the file
                (*entries)[i].git_status[0] = git_status.files[j].status;
                (*entries)[i].git_status[1] = '\0';
                break;  // Stop searching once a match is found
            }
        }

        // Check directories for modified files
        if ((*entries)[i].is_directory) {
            char full_path[MAX_PATH];
            // Construct the full path of the directory
            snprintf(full_path, sizeof(full_path), "%s/%s", current_dir, (*entries)[i].name);
            // Check if the directory contains modified files
            (*entries)[i].contains_modified = has_modified_files(full_path);
        }
    }
}
/**
 * @file git_integration.h
 * @brief Header file for Git integration functionality.
 *
 * This file declares the interface for integrating Git status information
 * into the file entries displayed by the facad tool. It provides the
 * necessary function declarations and includes required dependencies.
 *
 * @author Sergey Veneckiy
 * @date 2024
 */

#ifndef GIT_INTEGRATION_H
#define GIT_INTEGRATION_H

#include "file_card.h"  // Include for FileCardInfo structure
#include "git_utils.h"  // Include for Git-related utility functions

/**
 * @brief Integrates Git status information into file entries.
 *
 * This function retrieves the Git status for files in the current directory
 * and updates the corresponding FileCardInfo structures with this information.
 * It should be called after file entries are created but before they are displayed.
 *
 * @param entries Pointer to an array of FileCardInfo pointers. Each entry represents a file or directory.
 * @param num_entries Pointer to the number of entries in the array. This allows for potential modification of the entry count.
 * @param current_dir The current directory path. This is used to construct relative paths for Git status comparison.
 *
 * @note This function modifies the git_status field of each FileCardInfo structure in the entries array.
 * @note If the current directory is not a Git repository, this function will have no effect.
 */
void integrate_git_status(FileCardInfo** entries, int* num_entries, const char* current_dir);

#endif // GIT_INTEGRATION_H
/**
 * @file git_utils.c
 * @brief Implementation of Git utility functions for facad.
 *
 * This file contains utility functions for interacting with Git repositories.
 * It provides functionality to check if the current directory is a Git repository,
 * retrieve Git status information, and get the current branch name.
 *
 * @author Sergey Veneckiy
 * @date 2024
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "git_utils.h"

/**
 * @brief Checks if the current directory is part of a Git repository.
 *
 * This function executes the 'git rev-parse' command to determine
 * if the current working directory is within a Git repository.
 *
 * @return true if the current directory is in a Git repository, false otherwise.
 */
bool is_git_repository() {
    // Execute 'git rev-parse' command and redirect output to /dev/null
    FILE* fp = popen("git rev-parse --is-inside-work-tree 2>/dev/null", "r");
    if (fp == NULL) {
        return false;  // Return false if command execution failed
    }

    char buffer[128];  // Buffer to store command output
    // Read command output and check if it's "true"
    bool result = fgets(buffer, sizeof(buffer), fp) != NULL && strcmp(buffer, "true\n") == 0;
    pclose(fp);  // Close the command pipe
    return result;  // Return the result
}

/**
 * @brief Parses a Git status string and returns a single character status code.
 *
 * This function interprets the two-character Git status string and
 * returns a single character representing the file's status.
 *
 * @param status_str Two-character Git status string.
 * @return Single character representing the file's Git status.
 */
static char parse_status(const char* status_str) {
    if (status_str[0] == '?' && status_str[1] == '?') return '?';  // Untracked
    return status_str[0] != ' ' ? status_str[0] : status_str[1];   // Modified, Staged, etc.
}

/**
 * @brief Retrieves the Git status for all files in the current repository.
 *
 * This function executes 'git status' command and parses its output to create
 * a list of files with their corresponding Git status.
 *
 * @return GitFileList structure containing the status of all files in the repository.
 */
GitFileList get_git_status() {
    GitFileList list = {0};  // Initialize an empty GitFileList

    // Execute 'git status' command
    FILE* fp = popen("git status -s", "r");
    if (fp == NULL) {
        return list;  // Return empty list if command execution failed
    }

    char line[MAX_FILENAME + 3];  // Buffer to store each line of output
    // Read each line of the command output
    while (fgets(line, sizeof(line), fp) != NULL && list.count < MAX_FILES) {
        if (strlen(line) > 3) {  // Ensure the line has enough characters
            GitFile file;
            file.status = parse_status(line);  // Parse the status
            // Copy the filename, skipping the first 3 characters (status and space)
            strncpy(file.filename, line + 3, MAX_FILENAME - 1);
            file.filename[strcspn(file.filename, "\n")] = 0;  // Remove newline
            list.files[list.count++] = file;  // Add file to the list
        }
    }

    pclose(fp);  // Close the command pipe
    return list;  // Return the populated list
}

/**
 * @brief Retrieves the name of the current Git branch.
 *
 * This function executes 'git rev-parse' command to get the name of the
 * current Git branch.
 *
 * @return Dynamically allocated string containing the branch name, or NULL if an error occurred.
 * @note The caller is responsible for freeing the returned string.
 */
char* get_current_branch() {
    // Execute 'git rev-parse' command to get the branch name
    FILE* fp = popen("git rev-parse --abbrev-ref HEAD 2>/dev/null", "r");
    if (fp == NULL) {
        return NULL;  // Return NULL if command execution failed
    }

    char* branch = malloc(256);  // Allocate memory for the branch name
    if (fgets(branch, 256, fp) == NULL) {  // Read the branch name
        free(branch);  // Free allocated memory if read failed
        pclose(fp);    // Close the command pipe
        return NULL;   // Return NULL to indicate failure
    }

    pclose(fp);  // Close the command pipe
    branch[strcspn(branch, "\n")] = 0;  // Remove newline character
    return branch;  // Return the branch name
}
/**
 * @file git_utils.h
 * @brief Header file for Git utility functions used in facad.
 *
 * This file declares structures and functions for interacting with Git repositories.
 * It provides functionality to check if a directory is a Git repository,
 * retrieve Git status information, and get the current branch name.
 *
 * @author Sergey Veneckiy
 * @date 2024
 */

#ifndef GIT_UTILS_H
#define GIT_UTILS_H

#include <stdbool.h>  // Include for boolean type

#define MAX_FILENAME 1024  // Maximum length for filenames
#define MAX_FILES 1000     // Maximum number of files to track

/**
 * @struct GitFile
 * @brief Structure to hold information about a single file's Git status.
 */
typedef struct {
    char filename[MAX_FILENAME];  // Name of the file
    char status;                  // Single character representing Git status
} GitFile;

/**
 * @struct GitFileList
 * @brief Structure to hold Git status information for multiple files.
 */
typedef struct {
    GitFile files[MAX_FILES];  // Array of GitFile structures
    int count;                 // Number of files in the list
} GitFileList;

/**
 * @brief Checks if the current directory is part of a Git repository.
 *
 * This function determines whether the current working directory
 * is within a Git repository.
 *
 * @return true if the current directory is in a Git repository, false otherwise.
 */
bool is_git_repository(void);

/**
 * @brief Retrieves the Git status for all files in the current repository.
 *
 * This function gets the status of all files in the current Git repository,
 * including untracked, modified, and staged files.
 *
 * @return GitFileList structure containing the status of all files in the repository.
 */
GitFileList get_git_status(void);

/**
 * @brief Retrieves the name of the current Git branch.
 *
 * This function gets the name of the current Git branch in the repository.
 *
 * @return Dynamically allocated string containing the branch name, or NULL if an error occurred.
 * @note The caller is responsible for freeing the returned string.
 */
char* get_current_branch(void);

#endif // GIT_UTILS_H
/**
 * @file longlisting.c
 * @brief Implementation of detailed directory listing functionality.
 *
 * This file contains functions for generating and displaying a detailed
 * listing of directory contents, including file sizes, permissions,
 * modification times, and other attributes.
 *
 * @author Sergey Veneckiy
 * @date 2024
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <dirent.h>
#include <time.h>
#include <pwd.h>
#include <grp.h>
#include <locale.h>
#include <errno.h>
#include <unistd.h>
#include <glob.h>
#include "longlisting.h"
#include "emoji_utils.h"

#define MAX_PATH 4096
#define MAX_ENTRIES 1000
#define MAX_TIME_AGO_LEN 30

/**
 * @struct file_info
 * @brief Structure to hold detailed information about a file or directory.
 */
struct file_info {
    char name[256];             /**< Name of the file or directory */
    char full_path[MAX_PATH];   /**< Full path to the file or directory */
    off_t size;                 /**< Size of the file or directory */
    mode_t mode;                /**< File mode (permissions) */
    time_t mtime;               /**< Last modification time */
    int is_dir;                 /**< Flag indicating if it's a directory */
    int subdir_count;           /**< Number of subdirectories (for directories) */
    char owner[256];            /**< Owner of the file or directory */
    char user_rights[16];       /**< User rights represented as emojis */
    char time_ago[MAX_TIME_AGO_LEN]; /**< Human-readable time since last modification */
};

// Function prototypes
static char *format_size(off_t size);
static void format_time_ago(time_t file_time, char *buf, size_t buf_size);
static void get_user_rights(mode_t mode, char *rights);
static off_t get_dir_size(const char *path);
static int count_subdirs(const char *path);
static int compare_entries(const void *a, const void *b);
static int get_file_info(const char *path, struct file_info *fi, size_t *max_owner_len, size_t *max_time_ago_len);
static void print_sorted_entries(struct file_info *entries, int entry_count, size_t max_owner_len, size_t max_time_ago_len);

/**
 * @brief Formats a file size into a human-readable string.
 *
 * @param size The size in bytes to format.
 * @return A pointer to a static buffer containing the formatted size string.
 */
static char *format_size(off_t size) {
    static char buf[64];
    const char *units[] = {"B", "K", "M", "G", "T", "P", "E", "Z", "Y"};
    int i = 0;
    double dsize = size;

    while (dsize >= 1024 && i < 8) {
        dsize /= 1024;
        i++;
    }

    snprintf(buf, sizeof(buf), "%.1f%s", dsize, units[i]);
    return buf;
}

/**
 * @brief Formats the time difference between now and a given time into a human-readable string.
 *
 * @param file_time The time to format.
 * @param buf Buffer to store the formatted string.
 * @param buf_size Size of the buffer.
 */
static void format_time_ago(time_t file_time, char *buf, size_t buf_size) {
    time_t now = time(NULL);
    double seconds = difftime(now, file_time);
    int minutes = (int)(seconds / 60);
    int hours = minutes / 60;
    int days = hours / 24;
    int months = days / 30;  // Approximation
    int years = days / 365;  // Approximation

    if (years > 0) {
        snprintf(buf, buf_size, "%dy %dm ago", years, months % 12);
    } else if (months > 0) {
        snprintf(buf, buf_size, "%dm %dd ago", months, days % 30);
    } else if (days > 0) {
        snprintf(buf, buf_size, "%dd ago", days);
    } else if (hours > 0) {
        snprintf(buf, buf_size, "%dh ago", hours);
    } else if (minutes > 0) {
        snprintf(buf, buf_size, "%dm ago", minutes);
    } else {
        snprintf(buf, buf_size, "just now");
    }
}

/**
 * @brief Converts file permissions to a string of emojis representing user rights.
 *
 * @param mode The file mode containing the permissions.
 * @param rights Buffer to store the emoji string.
 */
static void get_user_rights(mode_t mode, char *rights) {
    const char *read = "\xF0\x9F\x91\x80";           // 👀
    const char *write = "\xE2\x9C\x8F\xEF\xB8\x8F "; // ✏️
    const char *exec = "\xF0\x9F\x9A\x80";           // 🚀
    const char *no = "\xE2\x9D\x8C";                 // ❌

    strcpy(rights, "");
    strcat(rights, (mode & S_IRUSR) ? read : no);
    strcat(rights, (mode & S_IWUSR) ? write : no);
    strcat(rights, (mode & S_IXUSR) ? exec : no);
}

/**
 * @brief Calculates the total size of a directory and its contents.
 *
 * @param path The path of the directory.
 * @return The total size of the directory in bytes.
 */
static off_t get_dir_size(const char *path) {
    DIR *dir;
    struct dirent *entry;
    struct stat st;
    off_t total_size = 0;
    char full_path[MAX_PATH];

    dir = opendir(path);
    if (!dir) return 0;

    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) continue;

        snprintf(full_path, sizeof(full_path), "%s/%s", path, entry->d_name);

        if (lstat(full_path, &st) == 0) {
            if (S_ISDIR(st.st_mode)) {
                total_size += get_dir_size(full_path);
            } else {
                total_size += st.st_size;
            }
        }
    }
    closedir(dir);
    return total_size;
}

/**
 * @brief Counts the number of subdirectories in a given directory.
 *
 * @param path The path of the directory.
 * @return The number of subdirectories.
 */
static int count_subdirs(const char *path) {
    DIR *dir;
    struct dirent *entry;
    int count = 0;

    dir = opendir(path);
    if (!dir) return 0;

    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) continue;

        char full_path[MAX_PATH];
        snprintf(full_path, sizeof(full_path), "%s/%s", path, entry->d_name);

        struct stat st;
        if (stat(full_path, &st) == 0 && S_ISDIR(st.st_mode)) {
            count++;
        }
    }
    closedir(dir);
    return count;
}

/**
 * @brief Comparison function for sorting file_info structures.
 *
 * @param a Pointer to the first file_info structure.
 * @param b Pointer to the second file_info structure.
 * @return Integer less than, equal to, or greater than zero if a is found,
 *         respectively, to be less than, to match, or be greater than b.
 */
static int compare_entries(const void *a, const void *b) {
    const struct file_info *fa = (const struct file_info *)a;
    const struct file_info *fb = (const struct file_info *)b;

    if (fa->is_dir && !fb->is_dir) return -1;
    if (!fa->is_dir && fb->is_dir) return 1;

    if (fa->is_dir && fb->is_dir) {
        if (fa->subdir_count != fb->subdir_count) {
            return fb->subdir_count - fa->subdir_count;
        }
        if (fa->size != fb->size) {
            return (fa->size < fb->size) ? 1 : -1;
        }
    }

    if (!fa->is_dir && !fb->is_dir) {
        if (fa->size != fb->size) {
            return (fa->size < fb->size) ? 1 : -1;
        }
    }

    return strcasecmp(fa->name, fb->name);
}

/**
 * @brief Gets detailed information about a file.
 *
 * @param path The path to the file.
 * @param fi Pointer to a file_info structure to populate.
 * @param max_owner_len Pointer to store the maximum owner name length.
 * @param max_time_ago_len Pointer to store the maximum time ago string length.
 * @return 0 on success, -1 on failure.
 */
static int get_file_info(const char *path, struct file_info *fi, size_t *max_owner_len, size_t *max_time_ago_len) {
    struct stat st;
    if (lstat(path, &st) != 0) return -1;

    strncpy(fi->name, path, sizeof(fi->name) - 1);
    fi->name[sizeof(fi->name) - 1] = '\0';
    strncpy(fi->full_path, path, sizeof(fi->full_path) - 1);
    fi->full_path[sizeof(fi->full_path) - 1] = '\0';

    fi->mode = st.st_mode;
    fi->mtime = st.st_mtime;
    fi->is_dir = S_ISDIR(st.st_mode);
    fi->size = fi->is_dir ? get_dir_size(path) : st.st_size;
    fi->subdir_count = fi->is_dir ? count_subdirs(path) : 0;

    struct passwd *pw = getpwuid(st.st_uid);
    if (pw) {
        strncpy(fi->owner, pw->pw_name, sizeof(fi->owner) - 1);
    } else {
        snprintf(fi->owner, sizeof(fi->owner), "%d", st.st_uid);
    }

    size_t owner_len = strlen(fi->owner);
    if (owner_len > *max_owner_len) {
        *max_owner_len = owner_len;
    }

    format_time_ago(fi->mtime, fi->time_ago, sizeof(fi->time_ago));
    size_t time_ago_len = strlen(fi->time_ago);
    if (time_ago_len > *max_time_ago_len) {
        *max_time_ago_len = time_ago_len;
    }

    get_user_rights(fi->mode, fi->user_rights);

    return 0;
}

/**
 * @brief Prints sorted entries in a detailed format.
 *
 * @param entries Array of file_info structures.
 * @param entry_count Number of entries in the array.
 * @param max_owner_len Maximum length of owner names.
 * @param max_time_ago_len Maximum length of time ago strings.
 */
static void print_sorted_entries(struct file_info *entries, int entry_count, size_t max_owner_len, size_t max_time_ago_len) {
    for (int i = 0; i < entry_count; i++) {
        struct file_info *fi = &entries[i];
        char *emoji = get_emoji(fi->full_path);

        printf("%8s  %-*s  \xF0\x9F\x91\x91: %-*s \xF0\x9F\x93\x9C: %s  %s %-17s",
               format_size(fi->size),
               (int)max_time_ago_len, fi->time_ago,
               (int)max_owner_len, fi->owner,
               fi->user_rights,
               emoji,
               fi->name);

        if (fi->is_dir) {
            printf("(%d)", fi->subdir_count);
        }
        printf("\n");

        free(emoji);
    }
}

/**
 * @brief Prints a detailed listing of the contents of a directory.
 *
 * @param path The path of the directory to list.
 */
void print_longlisting(const char *path) {
    setlocale(LC_ALL, "");

    struct file_info entries[MAX_ENTRIES];
    int entry_count = 0;
    size_t max_owner_len = 0;
    size_t max_time_ago_len = 0;

    DIR *dir = opendir(path);
    if (!dir) {
        perror("Error opening directory");
        return;
    }

    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL && entry_count < MAX_ENTRIES) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) continue;

        char full_path[MAX_PATH];
        snprintf(full_path, sizeof(full_path), "%s/%s", path, entry->d_name);

        struct file_info *fi = &entries[entry_count];
        if (get_file_info(full_path, fi, &max_owner_len, &max_time_ago_len) == 0) {
            entry_count++;
        }
    }
    closedir(dir);

    qsort(entries, entry_count, sizeof(struct file_info), compare_entries);
    print_sorted_entries(entries, entry_count, max_owner_len, max_time_ago_len);
}


void print_longlisting_files(const char **patterns, int pattern_count) {
    struct file_info entries[MAX_ENTRIES];
    int entry_count = 0;
    size_t max_owner_len = 0;
    size_t max_time_ago_len = 0;

    for (int i = 0; i < pattern_count; i++) {
        glob_t globbuf;
        int glob_result = glob(patterns[i], GLOB_TILDE, NULL, &globbuf);

        if (glob_result == 0) {
            for (size_t j = 0; j < globbuf.gl_pathc && entry_count < MAX_ENTRIES; j++) {
                struct file_info *fi = &entries[entry_count];
                if (get_file_info(globbuf.gl_pathv[j], fi, &max_owner_len, &max_time_ago_len) == 0) {
                    entry_count++;
                }
            }
        } else {
            fprintf(stderr, "glob error for pattern '%s': %s\n", patterns[i], strerror(errno));
        }
        globfree(&globbuf);
    }

    if (entry_count > 0) {
        qsort(entries, entry_count, sizeof(struct file_info), compare_entries);
        print_sorted_entries(entries, entry_count, max_owner_len, max_time_ago_len);
    } else {
        fprintf(stderr, "No matching files found.\n");
    }
}
#ifndef LONGLISTING_H
#define LONGLISTING_H

void print_longlisting(const char *path);
void print_longlisting_files(const char **patterns, int pattern_count);

#endif // LONGLISTING_H

/**
 * @file main.c
 * @brief Main entry point for the facad directory listing tool.
 *
 * This file contains the main function and core logic for the facad tool,
 * which provides a colorful and feature-rich directory listing in the terminal.
 * It handles command-line arguments, processes directories or files,
 * and displays the results using various output formats.
 *
 * @author Sergey Veneckiy
 * @date 2024
 */

#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <dirent.h>
#include <fnmatch.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#ifdef __APPLE__
#include <sys/syslimits.h> // `PATH_MAX` on macOS exists in this header
#endif

#include "git_utils.h"
#include "file_card.h"
#include "dir_config.h"
#include "args_parser.h"
#include "longlisting.h"
#include "dir_analytics.h"
#include "display_utils.h"
#include "dev_dir_utils.h"
#include "git_integration.h"

#define MAX_PATH PATH_MAX    // Maximum length for file paths
#define INITIAL_ENTRIES 512  // Initial number of directory entries to allocate

/**
 * @brief Dynamically allocates or reallocates memory for directory entries.
 *
 * This function manages the memory for the array of FileCardInfo structures.
 * It starts with INITIAL_ENTRIES and doubles the size when more space is needed.
 *
 * @param entries Pointer to the array of FileCardInfo structures.
 * @param current_size Pointer to the current size of the array.
 * @return 0 on success, -1 on failure.
 */
static int allocate_entries(FileCardInfo **entries, int *current_size) {
    // Calculate new size (double the current size or use initial size if NULL)
    int new_size = (*entries == NULL) ? INITIAL_ENTRIES : (*current_size * 2);

    // Attempt to reallocate memory for entries
    FileCardInfo *new_entries = realloc(*entries, new_size * sizeof(FileCardInfo));

    // Check if reallocation was successful
    if (new_entries == NULL) {
        perror("Failed to allocate memory for entries"); // Print error message
        return -1;  // Return -1 to indicate failure
    }

    // Update entries pointer and current size
    *entries = new_entries;
    *current_size = new_size;
    return 0;  // Return 0 to indicate success
}

/**
 * @brief Processes directory entries and populates the entries array.
 *
 * This function reads directory contents, creates FileCardInfo structures for each entry,
 * and dynamically allocates memory as needed. It also integrates Git status information.
 *
 * @param dir_path Path to the directory to process.
 * @param entries Pointer to the array of FileCardInfo structures.
 * @param num_entries Pointer to the number of entries processed.
 * @param current_size Pointer to the current size of the entries array.
 * @return 0 on success, -1 on failure.
 */
static int process_directory(const char *dir_path, FileCardInfo **entries, int *num_entries, int *current_size) {
    DIR *dir = opendir(dir_path); // Open the directory
    if (dir == NULL) {
        perror("Error opening directory"); // Print error message if directory can't be opened
        return -1;
    }

    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL) { // Loop through each entry in the directory
        // Skip '.' and '..' entries
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
            continue;
        }

        // Check if we need to allocate more memory
        if (*num_entries >= *current_size) {
            if (allocate_entries(entries, current_size) != 0) {
                closedir(dir); // Close the directory before returning
                return -1;
            }
        }

        // Construct full path for the current entry
        char full_path[MAX_PATH];
        snprintf(full_path, sizeof(full_path), "%s/%s", dir_path, entry->d_name);

        // Create a file entry and add it to the array
        if (create_file_entry(&(*entries)[*num_entries], entry->d_name) != 0) {
            fprintf(stderr, "Warning: Unable to get info for %s: %s\n", full_path, strerror(errno));
            continue;
        }

        (*num_entries)++; // Increment the number of entries
    }

    closedir(dir); // Close the directory

    // Integrate Git status information for the entries
    integrate_git_status(entries, num_entries, dir_path);

    return 0; // Return 0 to indicate success
}

/**
 * @brief Processes files or patterns and populates the entries array.
 *
 * This function handles file patterns (including globs) and individual files,
 * creating FileCardInfo structures for matching entries.
 *
 * @param patterns Array of file patterns or names to process.
 * @param pattern_count Number of patterns in the array.
 * @param entries Pointer to the array of FileCardInfo structures.
 * @param num_entries Pointer to the number of entries processed.
 * @param current_size Pointer to the current size of the entries array.
 * @return 0 on success, -1 on failure.
 */
static int process_files_or_patterns(const char **patterns, int pattern_count, FileCardInfo **entries, int *num_entries, int *current_size) {
    DIR *dir;
    struct dirent *entry;
    char full_path[MAX_PATH];

    dir = opendir("."); // Open the current directory
    if (dir == NULL) {
        perror("Error opening current directory"); // Print error message if directory can't be opened
        return -1;
    }

    while ((entry = readdir(dir)) != NULL) { // Loop through each entry in the directory
        bool match = false;
        // Check if the entry matches any of the provided patterns
        for (int i = 0; i < pattern_count; i++) {
            if (fnmatch(patterns[i], entry->d_name, 0) == 0) {
                match = true;
                break;
            }
        }

        if (match) { // If the entry matches a pattern
            // Check if we need to allocate more memory
            if (*num_entries >= *current_size) {
                if (allocate_entries(entries, current_size) != 0) {
                    closedir(dir); // Close the directory before returning
                    return -1;
                }
            }

            // Create a file entry for the matching file
            snprintf(full_path, sizeof(full_path), "%s", entry->d_name);
            if (create_file_entry(&(*entries)[*num_entries], full_path) != 0) {
                fprintf(stderr, "Warning: Unable to get info for %s: %s\n", full_path, strerror(errno));
                continue;
            }

            (*num_entries)++; // Increment the number of entries
        }
    }

    closedir(dir); // Close the directory
    return *num_entries > 0 ? 0 : -1; // Return 0 if entries were found, -1 otherwise
}

/**
 * @brief Checks if a given path is a directory.
 *
 * @param path The path to check.
 * @return 1 if the path is a directory, 0 otherwise.
 */
static int is_directory(const char *path) {
    struct stat statbuf;
    if (stat(path, &statbuf) != 0) // Get file status
        return 0; // Return 0 if stat fails
    return S_ISDIR(statbuf.st_mode); // Return 1 if it's a directory, 0 otherwise
}

/**
 * @brief Processes a single target (directory, file, or pattern).
 *
 * This function handles different types of targets: directories, glob patterns,
 * and individual files. It populates the entries array accordingly.
 *
 * @param target The target to process (directory path, file path, or pattern).
 * @param entries Pointer to the array of FileCardInfo structures.
 * @param num_entries Pointer to the number of entries processed.
 * @param current_size Pointer to the current size of the entries array.
 * @return 0 on success, -1 on failure.
 */
static int process_target(const char *target, FileCardInfo **entries, int *num_entries, int *current_size) {
    if (is_directory(target)) { // If the target is a directory
        char previous_dir[MAX_PATH];
        if (getcwd(previous_dir, sizeof(previous_dir)) == NULL) { // Get current working directory
            perror("getcwd() error");
            return -1;
        }

        if (chdir(target) != 0) { // Change to the target directory
            fprintf(stderr, "Error changing to directory '%s': %s\n", target, strerror(errno));
            return -1;
        }

        int result = process_directory(".", entries, num_entries, current_size); // Process the directory

        // Change back to the previous directory
        if (chdir(previous_dir) != 0) {
            fprintf(stderr, "Error changing back to previous directory: %s\n", strerror(errno));
            return -1;
        }

        return result;
    } else if (is_glob_pattern(target)) { // If the target is a glob pattern
        return process_files_or_patterns(&target, 1, entries, num_entries, current_size);
    } else { // Assume it's a single file
        // Check if we need to allocate more memory
        if (*num_entries >= *current_size) {
            if (allocate_entries(entries, current_size) != 0) {
                return -1;
            }
        }
        // Create a file entry for the single file
        if (create_file_entry(&(*entries)[*num_entries], target) != 0) {
            fprintf(stderr, "Unable to get info for %s: %s\n", target, strerror(errno));
            return -1;
        }
        (*num_entries)++; // Increment the number of entries
    }
    return 0; // Return 0 to indicate success
}

/**
 * @brief Checks if the targets are glob patterns or specific files.
 *
 * This function determines whether the given targets include glob patterns
 * or specific files, as opposed to just directories.
 *
 * @param targets Array of target strings.
 * @param target_count Number of targets in the array.
 * @return 1 if glob patterns or specific files are present, 0 otherwise.
 */
static int is_glob_or_specific_files(const char **targets, int target_count) {
    for (int i = 0; i < target_count; i++) {
        if (is_glob_pattern(targets[i]) || !is_directory(targets[i])) {
            return 1; // Return 1 if a glob pattern or non-directory is found
        }
    }
    return 0; // Return 0 if all targets are directories
}

/**
 * @brief Main function of the facad program.
 *
 * This function serves as the entry point for the facad directory listing tool.
 * It parses command-line arguments, processes directories or files based on the input,
 * and displays the results using the appropriate format (standard, long listing, or analytics).
 *
 * @param argc Number of command-line arguments.
 * @param argv Array of command-line argument strings.
 * @return EXIT_SUCCESS on successful execution, EXIT_FAILURE on error.
 */
int main(int argc, char *argv[]) {
    CommandLineArgs args = parse_args(argc, argv); // Parse command-line arguments

    // Handle version display request
    if (args.show_version) {
        print_version();
        free_args(&args);
        return EXIT_SUCCESS;
    }

    // Handle help display request
    if (args.show_help) {
        print_help(argv[0]);
        free_args(&args);
        return EXIT_SUCCESS;
    }

    // Handle invalid options
    if (args.invalid_opt) {
        fprintf(stderr, "%s: unrecognized option '%s'\n", argv[0], args.invalid_opt);
        fprintf(stderr, "Try '%s --help' for more information.\n", argv[0]);
        free_args(&args);
        return EXIT_FAILURE;
    }

    // Get current working directory
    char current_dir[MAX_PATH];
    if (getcwd(current_dir, sizeof(current_dir)) == NULL) {
        perror("getcwd() error");
        free_args(&args);
        return EXIT_FAILURE;
    }

    // Handle long listing request
    if (args.show_longlisting) {
        if (args.target_count > 0 && is_glob_or_specific_files(args.targets, args.target_count)) {
            print_longlisting_files(args.targets, args.target_count);
        } else {
            print_longlisting(args.target_count > 0 ? args.targets[0] : ".");
        }
        free_args(&args);
        return EXIT_SUCCESS;
    }

    // Handle directory analytics request
    if (args.show_dir_analytics) {
        print_dir_analytics(args.target_count > 0 ? args.targets[0] : ".");
        free_args(&args);
        return EXIT_SUCCESS;
    }

    // Get terminal width for display formatting
    struct winsize w;
    ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);
    int term_width = w.ws_col;

    // Initialize variables for storing file entries
    FileCardInfo *entries = NULL;
    int num_entries = 0;
    int current_size = 0;

    // Set up display path
    char display_path[MAX_PATH];
    strcpy(display_path, current_dir);

    int show_path = 1; // Flag to determine if path should be displayed

    // Process targets if provided, otherwise process current directory
    if (args.target_count > 0) {
        show_path = 0; // Don't show path for specific targets
        for (int i = 0; i < args.target_count; i++) {
            // Get real path if possible
            char *real_path = realpath(args.targets[i], NULL);
            if (real_path != NULL) {
                strcpy(display_path, real_path);
                free(real_path);
            } else {
                strcpy(display_path, args.targets[i]);
            }

            // Process the target
            if (process_target(args.targets[i], &entries, &num_entries, &current_size) != 0) {
                fprintf(stderr, "Error processing '%s'\n", args.targets[i]);
                goto cleanup; // Jump to cleanup if there's an error
            }
        }
    } else {
        // Check if current directory is /dev and handle accordingly
        if (is_dev_directory(current_dir)) {
            strcpy(display_path, "/dev");
            if (handle_dev_directory(&entries, &num_entries, &current_size) != 0) {
                fprintf(stderr, "Error processing /dev directory\n");
                goto cleanup;
            }
        } else {
            // Process current directory
            if (process_directory(".", &entries, &num_entries, &current_size) != 0) {
                fprintf(stderr, "Error processing current directory\n");
                goto cleanup;
            }
        }
    }

    // Handle case when no entries are found
    if (num_entries == 0) {
        char current_dir[PATH_MAX];
        if (getcwd(current_dir, sizeof(current_dir)) != NULL) {
            // Display current directory if it matches the display path
            if (strcmp(current_dir, display_path) == 0) {
                printf("\033[1m%s\033[0m\n", current_dir);
            }
            fprintf(stderr, "🚫 No files found\n");
        } else {
            fprintf(stderr, "🚫 No files found\n");
        }
    } else {
        // Sort the entries alphabetically
        qsort(entries, num_entries, sizeof(FileCardInfo), compare_file_entries);

        // If in a Git repository, integrate Git status information
        if (is_git_repository()) {
            GitFileList git_status = get_git_status();
            for (int i = 0; i < num_entries; i++) {
                for (int j = 0; j < git_status.count; j++) {
                    // Match file names and set Git status
                    if (strcmp(entries[i].name, git_status.files[j].filename) == 0) {
                        entries[i].git_status[0] = git_status.files[j].status;
                        entries[i].git_status[1] = '\0';
                        break;
                    }
                }
            }
        }

        // Display the entries using the appropriate format
        display_entries(entries, num_entries, term_width, display_path, show_path);
    }

cleanup:
    // Free allocated memory for each entry
    for (int i = 0; i < num_entries; i++) {
        free_file_entry(&entries[i]);
    }
    free(entries); // Free the main entries array
    free_args(&args); // Free command-line arguments

    // Return success if entries were found, failure otherwise
    return num_entries > 0 ? EXIT_SUCCESS : EXIT_FAILURE;
}
❯ 
"""


The code above is the source code of my utility. The facade utility has a bottleneck. It works slowly in large repositories because of the Git integration. I need to fix this. Provide me with code that resolves this problem. You can't do whatever you want or invent any idea to solve this problem with maximum efficiency. But remember! All functionality must be preserved. This is crucial! The user must not see any difference. This is also crucial!
